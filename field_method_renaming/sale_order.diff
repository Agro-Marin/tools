diff --git a/addons/sale/models/sale_order.py b/addons/sale/models/sale_order.py
index b65bccd362f8..edd9325693ce 100644
--- a/addons/sale/models/sale_order.py
+++ b/addons/sale/models/sale_order.py
@@ -1,11 +1,8 @@
-# Part of Odoo. See LICENSE file for full copyright and licensing details.
-
 import json
 import logging
 from collections import defaultdict
 from datetime import timedelta
 from itertools import groupby
-
 from odoo import SUPERUSER_ID, _, api, fields, models
 from odoo.exceptions import AccessError, UserError, ValidationError
 from odoo.fields import Command, Domain
@@ -13,321 +10,89 @@ from odoo.http import request
 from odoo.tools import SQL, OrderedSet, float_is_zero, format_amount, is_html_empty
 from odoo.tools.mail import html_keep_url
 from odoo.tools.misc import str2bool
-
 from odoo.addons.payment import utils as payment_utils
-
-INVOICE_STATUS = [
-    ('upselling', 'Upselling Opportunity'),
-    ('invoiced', 'Fully Invoiced'),
-    ('to invoice', 'To Invoice'),
-    ('no', 'Nothing to Invoice')
-]
-
-SALE_ORDER_STATE = [
-    ('draft', "Quotation"),
-    ('sent', "Quotation Sent"),
-    ('sale', "Sales Order"),
-    ('cancel', "Cancelled"),
-]
-
+INVOICE_STATUS = [('upselling', 'Upselling Opportunity'), ('invoiced', 'Fully Invoiced'), ('to invoice', 'To Invoice'), ('no', 'Nothing to Invoice')]
+SALE_ORDER_STATE = [('draft', 'Quotation'), ('sent', 'Quotation Sent'), ('sale', 'Sales Order'), ('cancel', 'Cancelled')]
 
 class SaleOrder(models.Model):
     _name = 'sale.order'
     _inherit = ['portal.mixin', 'product.catalog.mixin', 'mail.thread', 'mail.activity.mixin', 'utm.mixin', 'account.document.import.mixin']
-    _description = "Sales Order"
+    _description = 'Sales Order'
     _order = 'date_order desc, id desc'
     _check_company_auto = True
-
-    _date_order_conditional_required = models.Constraint(
-        "CHECK((state = 'sale' AND date_order IS NOT NULL) OR state != 'sale')",
-        'A confirmed sales order requires a confirmation date.',
-    )
+    _date_order_conditional_required = models.Constraint("CHECK((state = 'sale' AND date_order IS NOT NULL) OR state != 'sale')", 'A confirmed sales order requires a confirmation date.')
 
     @property
     def _rec_names_search(self):
         if self.env.context.get('sale_show_partner_name'):
             return ['name', 'partner_id.name']
         return ['name']
-
-    #=== FIELDS ===#
-
-    name = fields.Char(
-        string="Order Reference",
-        required=True, copy=False, readonly=False,
-        index='trigram',
-        default=lambda self: _('New'))
-
-    company_id = fields.Many2one(
-        comodel_name='res.company',
-        required=True, index=True,
-        default=lambda self: self.env.company)
-    partner_id = fields.Many2one(
-        comodel_name='res.partner',
-        string="Customer",
-        required=True, change_default=True, index=True,
-        tracking=1,
-        check_company=True)
-    state = fields.Selection(
-        selection=SALE_ORDER_STATE,
-        string="Status",
-        readonly=True, copy=False, index=True,
-        tracking=3,
-        default='draft')
-    locked = fields.Boolean(
-        help="Locked orders cannot be modified.",
-        default=False,
-        copy=False,
-        tracking=True)
-    has_archived_products = fields.Boolean(compute="_compute_has_archived_products")
-
-    client_order_ref = fields.Char(string="Customer Reference", copy=False)
-    create_date = fields.Datetime(  # Override of default create_date field from ORM
-        string="Creation Date", index=True, readonly=True)
-    commitment_date = fields.Datetime(
-        string="Delivery Date", copy=False,
-        help="This is the delivery date promised to the customer. "
-             "If set, the delivery order will be scheduled based on "
-             "this date rather than product lead times.")
-    date_order = fields.Datetime(
-        string="Order Date",
-        required=True, copy=False,
-        help="Creation date of draft/sent orders,\nConfirmation date of confirmed orders.",
-        default=fields.Datetime.now)
-    origin = fields.Char(
-        string="Source Document",
-        help="Reference of the document that generated this sales order request")
-    reference = fields.Char(
-        string="Payment Ref.",
-        help="The payment communication of this sale order.",
-        copy=False)
-    pending_email_template_id = fields.Many2one(
-        string="Pending Email Template",
-        comodel_name='mail.template',
-        ondelete='set null',
-        readonly=True,
-    )  # The template of the pending email that must be sent asynchronously.
-
-    require_signature = fields.Boolean(
-        string="Online signature",
-        compute='_compute_require_signature',
-        store=True, readonly=False, precompute=True,
-        help="Request a online signature from the customer to confirm the order.")
-    require_payment = fields.Boolean(
-        string="Online payment",
-        compute='_compute_require_payment',
-        store=True, readonly=False, precompute=True,
-        help="Request a online payment from the customer to confirm the order.")
-    prepayment_percent = fields.Float(
-        string="Prepayment percentage",
-        compute='_compute_prepayment_percent',
-        store=True, readonly=False, precompute=True,
-        help="The percentage of the amount needed that must be paid by the customer to confirm the order.")
-
-    signature = fields.Image(
-        string="Signature",
-        copy=False, attachment=True, max_width=1024, max_height=1024)
-    signed_by = fields.Char(
-        string="Signed By", copy=False)
-    signed_on = fields.Datetime(
-        string="Signed On", copy=False)
-
-    validity_date = fields.Date(
-        string="Expiration",
-        help="Validity of the order, after that you will not able to sign & pay the quotation.",
-        compute='_compute_validity_date',
-        store=True, readonly=False, copy=False, precompute=True)
-    journal_id = fields.Many2one(
-        'account.journal', string="Invoicing Journal",
-        compute="_compute_journal_id", store=True, readonly=False, precompute=True,
-        domain=[('type', '=', 'sale')], check_company=True,
-        help="If set, the SO will invoice in this journal; "
-             "otherwise the sales journal with the lowest sequence is used.")
-
-    # Partner-based computes
-    note = fields.Html(
-        string="Terms and conditions",
-        compute='_compute_note',
-        store=True, readonly=False, precompute=True)
-
-    partner_invoice_id = fields.Many2one(
-        comodel_name='res.partner',
-        string="Invoice Address",
-        compute='_compute_partner_invoice_id',
-        store=True, readonly=False, required=True, precompute=True,
-        check_company=True,
-        index='btree_not_null')
-    partner_shipping_id = fields.Many2one(
-        comodel_name='res.partner',
-        string="Delivery Address",
-        compute='_compute_partner_shipping_id',
-        store=True, readonly=False, required=True, precompute=True,
-        check_company=True,
-        index='btree_not_null')
-
-    fiscal_position_id = fields.Many2one(
-        comodel_name='account.fiscal.position',
-        string="Fiscal Position",
-        compute='_compute_fiscal_position_id',
-        store=True, readonly=False, precompute=True, check_company=True,
-        help="Fiscal positions are used to adapt taxes and accounts for particular customers or sales orders/invoices."
-            "The default value comes from the customer.",
-    )
-    payment_term_id = fields.Many2one(
-        comodel_name='account.payment.term',
-        string="Payment Terms",
-        compute='_compute_payment_term_id',
-        store=True, readonly=False, precompute=True, check_company=True,  # Unrequired company
-        domain="['|', ('company_id', '=', False), ('company_id', '=', company_id)]")
-    preferred_payment_method_line_id = fields.Many2one(
-        comodel_name="account.payment.method.line", string="Payment Method",
-        compute="_compute_preferred_payment_method_line_id",
-        store=True, precompute=True, readonly=False, check_company=True,
-        domain="[('payment_type', '=', 'inbound'), ('company_id', '=', company_id)]")
-    pricelist_id = fields.Many2one(
-        comodel_name='product.pricelist',
-        string="Pricelist",
-        compute='_compute_pricelist_id',
-        store=True, readonly=False, precompute=True, check_company=True,  # Unrequired company
-        tracking=1,
-        domain="['|', ('company_id', '=', False), ('company_id', '=', company_id)]",
-        help="If you change the pricelist, only newly added lines will be affected.")
-    currency_id = fields.Many2one(
-        comodel_name='res.currency',
-        compute='_compute_currency_id',
-        store=True,
-        precompute=True,
-        ondelete='restrict'
-    )
-    currency_rate = fields.Float(
-        string="Currency Rate",
-        compute='_compute_currency_rate',
-        digits=0,
-        store=True, precompute=True)
-    user_id = fields.Many2one(
-        comodel_name='res.users',
-        string="Salesperson",
-        compute='_compute_user_id',
-        store=True, readonly=False, precompute=True, index=True,
-        tracking=2,
-        domain=lambda self: "[('all_group_ids', 'in', {}), ('share', '=', False), ('company_ids', '=', company_id)]".format(
-            self.env.ref("sales_team.group_sale_salesman").ids
-        ))
-    team_id = fields.Many2one(
-        comodel_name='crm.team',
-        string="Sales Team",
-        compute='_compute_team_id',
-        store=True, readonly=False, precompute=True, ondelete="set null",
-        change_default=True, check_company=True,  # Unrequired company
-        tracking=True,
-        domain="['|', ('company_id', '=', False), ('company_id', '=', company_id)]")
-
-    # Lines and line based computes
-    order_line = fields.One2many(
-        comodel_name='sale.order.line',
-        inverse_name='order_id',
-        string="Order Lines",
-        copy=True, bypass_search_access=True)
-
-    amount_untaxed = fields.Monetary(string="Untaxed Amount", store=True, compute='_compute_amounts', tracking=5)
-    amount_tax = fields.Monetary(string="Taxes", store=True, compute='_compute_amounts')
-    amount_total = fields.Monetary(string="Total", store=True, compute='_compute_amounts', tracking=4)
-    amount_to_invoice = fields.Monetary(string="Un-invoiced Balance", compute='_compute_amount_to_invoice')
-    amount_invoiced = fields.Monetary(string="Already invoiced", compute='_compute_amount_invoiced')
-
-    invoice_count = fields.Integer(string="Invoice Count", compute='_get_invoiced')
-    invoice_ids = fields.Many2many(
-        comodel_name='account.move',
-        string="Invoices",
-        compute='_get_invoiced',
-        search='_search_invoice_ids',
-        copy=False)
-    invoice_status = fields.Selection(
-        selection=INVOICE_STATUS,
-        string="Invoice Status",
-        compute='_compute_invoice_status',
-        store=True)
-
-    sale_warning_text = fields.Text(
-        "Sale Warning",
-        help="Internal warning for the partner or the products as set by the user.",
-        compute='_compute_sale_warning_text')
-
-    # Payment fields
-    transaction_ids = fields.Many2many(
-        comodel_name='payment.transaction',
-        relation='sale_order_transaction_rel', column1='sale_order_id', column2='transaction_id',
-        string="Transactions",
-        groups='account.group_account_invoice',
-        copy=False, readonly=True)
-    authorized_transaction_ids = fields.Many2many(
-        comodel_name='payment.transaction',
-        string="Authorized Transactions",
-        compute='_compute_authorized_transaction_ids',
-        copy=False,
-        groups='account.group_account_invoice',
-        compute_sudo=True)
-    has_authorized_transaction_ids = fields.Boolean(
-        string="Has Authorized Transactions",
-        compute='_compute_authorized_transaction_ids',
-        compute_sudo=True)
-    amount_paid = fields.Float(
-        string="Payment Transactions Amount",
-        help="Sum of transactions made in through the online payment form that are in the state"
-             " 'done' or 'authorized' and linked to this order.",
-        compute='_compute_amount_paid',
-        compute_sudo=True,
-    )
-
-    # UTMs - enforcing the fact that we want to 'set null' when relation is unlinked
+    name = fields.Char(string='Order Reference', required=True, copy=False, readonly=False, index='trigram', default=lambda self: _('New'))
+    company_id = fields.Many2one(comodel_name='res.company', required=True, index=True, default=lambda self: self.env.company)
+    partner_id = fields.Many2one(comodel_name='res.partner', string='Customer', required=True, change_default=True, index=True, tracking=1, check_company=True)
+    state = fields.Selection(selection=SALE_ORDER_STATE, string='Status', readonly=True, copy=False, index=True, tracking=3, default='draft')
+    locked = fields.Boolean(help='Locked orders cannot be modified.', default=False, copy=False, tracking=True)
+    has_archived_products = fields.Boolean(compute='_compute_has_archived_products')
+    client_order_ref = fields.Char(string='Customer Reference', copy=False)
+    create_date = fields.Datetime(string='Creation Date', index=True, readonly=True)
+    date_commitment = fields.Datetime(string='Delivery Date', copy=False, help='This is the delivery date promised to the customer. If set, the delivery order will be scheduled based on this date rather than product lead times.')
+    date_order = fields.Datetime(string='Order Date', required=True, copy=False, help='Creation date of draft/sent orders,\nConfirmation date of confirmed orders.', default=fields.Datetime.now)
+    origin = fields.Char(string='Source Document', help='Reference of the document that generated this sales order request')
+    reference = fields.Char(string='Payment Ref.', help='The payment communication of this sale order.', copy=False)
+    pending_email_template_id = fields.Many2one(string='Pending Email Template', comodel_name='mail.template', ondelete='set null', readonly=True)
+    require_signature = fields.Boolean(string='Online signature', compute='_compute_require_signature', store=True, readonly=False, precompute=True, help='Request a online signature from the customer to confirm the order.')
+    require_payment = fields.Boolean(string='Online payment', compute='_compute_require_payment', store=True, readonly=False, precompute=True, help='Request a online payment from the customer to confirm the order.')
+    prepayment_percent = fields.Float(string='Prepayment percentage', compute='_compute_prepayment_percent', store=True, readonly=False, precompute=True, help='The percentage of the amount needed that must be paid by the customer to confirm the order.')
+    signature = fields.Image(string='Signature', copy=False, attachment=True, max_width=1024, max_height=1024)
+    signed_by = fields.Char(string='Signed By', copy=False)
+    signed_on = fields.Datetime(string='Signed On', copy=False)
+    date_validity = fields.Date(string='Expiration', help='Validity of the order, after that you will not able to sign & pay the quotation.', compute='_compute_date_validity', store=True, readonly=False, copy=False, precompute=True)
+    journal_id = fields.Many2one('account.journal', string='Invoicing Journal', compute='_compute_journal_id', store=True, readonly=False, precompute=True, domain=[('type', '=', 'sale')], check_company=True, help='If set, the SO will invoice in this journal; otherwise the sales journal with the lowest sequence is used.')
+    note = fields.Html(string='Terms and conditions', compute='_compute_note', store=True, readonly=False, precompute=True)
+    partner_invoice_id = fields.Many2one(comodel_name='res.partner', string='Invoice Address', compute='_compute_partner_invoice_id', store=True, readonly=False, required=True, precompute=True, check_company=True, index='btree_not_null')
+    partner_shipping_id = fields.Many2one(comodel_name='res.partner', string='Delivery Address', compute='_compute_partner_shipping_id', store=True, readonly=False, required=True, precompute=True, check_company=True, index='btree_not_null')
+    fiscal_position_id = fields.Many2one(comodel_name='account.fiscal.position', string='Fiscal Position', compute='_compute_fiscal_position_id', store=True, readonly=False, precompute=True, check_company=True, help='Fiscal positions are used to adapt taxes and accounts for particular customers or sales orders/invoices.The default value comes from the customer.')
+    payment_term_id = fields.Many2one(comodel_name='account.payment.term', string='Payment Terms', compute='_compute_payment_term_id', store=True, readonly=False, precompute=True, check_company=True, domain="['|', ('company_id', '=', False), ('company_id', '=', company_id)]")
+    preferred_payment_method_line_id = fields.Many2one(comodel_name='account.payment.method.line', string='Payment Method', compute='_compute_preferred_payment_method_line_id', store=True, precompute=True, readonly=False, check_company=True, domain="[('payment_type', '=', 'inbound'), ('company_id', '=', company_id)]")
+    pricelist_id = fields.Many2one(comodel_name='product.pricelist', string='Pricelist', compute='_compute_pricelist_id', store=True, readonly=False, precompute=True, check_company=True, tracking=1, domain="['|', ('company_id', '=', False), ('company_id', '=', company_id)]", help='If you change the pricelist, only newly added lines will be affected.')
+    currency_id = fields.Many2one(comodel_name='res.currency', compute='_compute_currency_id', store=True, precompute=True, ondelete='restrict')
+    currency_rate = fields.Float(string='Currency Rate', compute='_compute_currency_rate', digits=0, store=True, precompute=True)
+    user_id = fields.Many2one(comodel_name='res.users', string='Salesperson', compute='_compute_user_id', store=True, readonly=False, precompute=True, index=True, tracking=2, domain=lambda self: "[('all_group_ids', 'in', {}), ('share', '=', False), ('company_ids', '=', company_id)]".format(self.env.ref('sales_team.group_sale_salesman').ids))
+    team_id = fields.Many2one(comodel_name='crm.team', string='Sales Team', compute='_compute_team_id', store=True, readonly=False, precompute=True, ondelete='set null', change_default=True, check_company=True, tracking=True, domain="['|', ('company_id', '=', False), ('company_id', '=', company_id)]")
+    line_ids = fields.One2many(comodel_name='sale.order.line', inverse_name='order_id', string='Order Lines', copy=True, bypass_search_access=True)
+    amount_untaxed = fields.Monetary(string='Untaxed Amount', store=True, compute='_compute_amounts', tracking=5)
+    amount_tax = fields.Monetary(string='Taxes', store=True, compute='_compute_amounts')
+    amount_total = fields.Monetary(string='Total', store=True, compute='_compute_amounts', tracking=4)
+    amount_to_invoice_taxinc = fields.Monetary(string='Un-invoiced Balance', compute='_compute_amount_to_invoice_taxinc')
+    amount_invoiced_taxinc = fields.Monetary(string='Already invoiced', compute='_compute_amount_invoiced_taxinc')
+    invoice_count = fields.Integer(string='Invoice Count', compute='_get_invoiced')
+    invoice_ids = fields.Many2many(comodel_name='account.move', string='Invoices', compute='_get_invoiced', search='_search_invoice_ids', copy=False)
+    invoice_state = fields.Selection(selection=INVOICE_STATUS, string='Invoice Status', compute='_compute_invoice_state', store=True)
+    sale_warning_text = fields.Text('Sale Warning', help='Internal warning for the partner or the products as set by the user.', compute='_compute_sale_warning_text')
+    transaction_ids = fields.Many2many(comodel_name='payment.transaction', relation='sale_order_transaction_rel', column1='sale_order_id', column2='transaction_id', string='Transactions', groups='account.group_account_invoice', copy=False, readonly=True)
+    authorized_transaction_ids = fields.Many2many(comodel_name='payment.transaction', string='Authorized Transactions', compute='_compute_authorized_transaction_ids', copy=False, groups='account.group_account_invoice', compute_sudo=True)
+    has_authorized_transaction_ids = fields.Boolean(string='Has Authorized Transactions', compute='_compute_authorized_transaction_ids', compute_sudo=True)
+    amount_paid = fields.Float(string='Payment Transactions Amount', help="Sum of transactions made in through the online payment form that are in the state 'done' or 'authorized' and linked to this order.", compute='_compute_amount_paid', compute_sudo=True)
     campaign_id = fields.Many2one(ondelete='set null')
     medium_id = fields.Many2one(ondelete='set null')
     source_id = fields.Many2one(ondelete='set null')
-
-    # Followup ?
-    tag_ids = fields.Many2many(
-        comodel_name='crm.tag',
-        relation='sale_order_tag_rel', column1='order_id', column2='tag_id',
-        groups="sales_team.group_sale_salesman",
-        string="Tags")
-
-    # Remaining non stored computed fields (hide/make fields readonly, ...)
-    amount_undiscounted = fields.Float(
-        string="Amount Before Discount",
-        compute='_compute_amount_undiscounted', digits=0)
-    country_code = fields.Char(related='company_id.account_fiscal_country_id.code', string="Country code")
+    tag_ids = fields.Many2many(comodel_name='crm.tag', relation='sale_order_tag_rel', column1='order_id', column2='tag_id', groups='sales_team.group_sale_salesman', string='Tags')
+    amount_undiscounted = fields.Float(string='Amount Before Discount', compute='_compute_amount_undiscounted', digits=0)
+    country_code = fields.Char(related='company_id.account_fiscal_country_id.code', string='Country code')
     company_price_include = fields.Selection(related='company_id.account_price_include')
     duplicated_order_ids = fields.Many2many(comodel_name='sale.order', compute='_compute_duplicated_order_ids')
-    expected_date = fields.Datetime(
-        string="Expected Date",
-        compute='_compute_expected_date', store=False,  # Note: can not be stored since depends on today()
-        help="Delivery date you can promise to the customer, computed from the minimum lead time of the order lines.")
-    is_expired = fields.Boolean(string="Is Expired", compute='_compute_is_expired')
-    partner_credit_warning = fields.Text(
-        compute='_compute_partner_credit_warning')
-    tax_calculation_rounding_method = fields.Selection(
-        related='company_id.tax_calculation_rounding_method',
-        depends=['company_id'])
-    tax_country_id = fields.Many2one(
-        comodel_name='res.country',
-        compute='_compute_tax_country_id',
-        # Avoid access error on fiscal position when reading a sale order with company != user.company_ids
-        compute_sudo=True)  # used to filter available taxes depending on the fiscal country and position
+    expected_date = fields.Datetime(string='Expected Date', compute='_compute_expected_date', store=False, help='Delivery date you can promise to the customer, computed from the minimum lead time of the order lines.')
+    is_expired = fields.Boolean(string='Is Expired', compute='_compute_is_expired')
+    partner_credit_warning = fields.Text(compute='_compute_partner_credit_warning')
+    tax_calculation_rounding_method = fields.Selection(related='company_id.tax_calculation_rounding_method', depends=['company_id'])
+    tax_country_id = fields.Many2one(comodel_name='res.country', compute='_compute_tax_country_id', compute_sudo=True)
     tax_totals = fields.Binary(compute='_compute_tax_totals', exportable=False)
     terms_type = fields.Selection(related='company_id.terms_type')
-    type_name = fields.Char(string="Type Name", compute='_compute_type_name')
-
-    # Remaining ux fields (not computed, not stored)
-
-    show_update_fpos = fields.Boolean(
-        string="Has Fiscal Position Changed", store=False)  # True if the fiscal position was changed
-    has_active_pricelist = fields.Boolean(
-        compute='_compute_has_active_pricelist')
-    show_update_pricelist = fields.Boolean(
-        string="Has Pricelist Changed", store=False)  # True if the pricelist was changed
-
-    _date_order_id_idx = models.Index("(date_order desc, id desc)")
-
-    #=== COMPUTE METHODS ===#
+    type_name = fields.Char(string='Type Name', compute='_compute_type_name')
+    show_update_fpos = fields.Boolean(string='Has Fiscal Position Changed', store=False)
+    has_active_pricelist = fields.Boolean(compute='_compute_has_active_pricelist')
+    show_update_pricelist = fields.Boolean(string='Has Pricelist Changed', store=False)
+    _date_order_id_idx = models.Index('(date_order desc, id desc)')
 
     @api.depends('partner_id')
     @api.depends_context('sale_show_partner_name')
@@ -343,9 +108,7 @@ class SaleOrder(models.Model):
     @api.depends('order_line.product_id')
     def _compute_has_archived_products(self):
         for order in self:
-            order.has_archived_products = any(
-                not product.active for product in order.order_line.product_id
-            )
+            order.has_archived_products = any((not product.active for product in order.order_line.product_id))
 
     @api.depends('company_id')
     def _compute_require_signature(self):
@@ -363,7 +126,7 @@ class SaleOrder(models.Model):
             order.prepayment_percent = order.company_id.prepayment_percent
 
     @api.depends('company_id')
-    def _compute_validity_date(self):
+    def _compute_date_validity(self):
         today = fields.Date.context_today(self)
         for order in self:
             days = order.company_id.quotation_validity_days
@@ -419,9 +182,7 @@ class SaleOrder(models.Model):
             fpos_id_before = order.fiscal_position_id.id
             key = (order.company_id.id, order.partner_id.id, order.partner_shipping_id.id)
             if key not in cache:
-                cache[key] = self.env['account.fiscal.position'].with_company(
-                    order.company_id
-                )._get_fiscal_position(order.partner_id, order.partner_shipping_id).id
+                cache[key] = self.env['account.fiscal.position'].with_company(order.company_id)._get_fiscal_position(order.partner_id, order.partner_shipping_id).id
             if fpos_id_before != cache[key] and order.order_line:
                 order.show_update_fpos = True
             order.fiscal_position_id = cache[key]
@@ -457,33 +218,18 @@ class SaleOrder(models.Model):
     @api.depends('currency_id', 'date_order', 'company_id')
     def _compute_currency_rate(self):
         for order in self:
-            order.currency_rate = self.env['res.currency']._get_conversion_rate(
-                from_currency=order.company_id.currency_id,
-                to_currency=order.currency_id,
-                company=order.company_id,
-                date=(order.date_order or fields.Datetime.now()).date(),
-            )
+            order.currency_rate = self.env['res.currency']._get_conversion_rate(from_currency=order.company_id.currency_id, to_currency=order.currency_id, company=order.company_id, date=(order.date_order or fields.Datetime.now()).date())
 
     @api.depends('company_id')
     def _compute_has_active_pricelist(self):
         for order in self:
-            order.has_active_pricelist = bool(self.env['product.pricelist'].search(
-                [('company_id', 'in', (False, order.company_id.id)), ('active', '=', True)],
-                limit=1,
-            ))
+            order.has_active_pricelist = bool(self.env['product.pricelist'].search([('company_id', 'in', (False, order.company_id.id)), ('active', '=', True)], limit=1))
 
     @api.depends('partner_id')
     def _compute_user_id(self):
         for order in self:
-            if order.partner_id and not (order._origin.id and order.user_id):
-                # Recompute the salesman on partner change
-                #   * if partner is set (is required anyway, so it will be set sooner or later)
-                #   * if the order is not saved or has no salesman already
-                order.user_id = (
-                    order.partner_id.user_id
-                    or order.partner_id.commercial_partner_id.user_id
-                    or (self.env.user.has_group('sales_team.group_sale_salesman') and self.env.user)
-                )
+            if order.partner_id and (not (order._origin.id and order.user_id)):
+                order.user_id = order.partner_id.user_id or order.partner_id.commercial_partner_id.user_id or (self.env.user.has_group('sales_team.group_sale_salesman') and self.env.user)
 
     @api.depends('user_id')
     def _compute_team_id(self):
@@ -494,12 +240,7 @@ class SaleOrder(models.Model):
             company_id = order.company_id.id
             key = (default_team_id, user_id, company_id)
             if key not in cached_teams:
-                cached_teams[key] = self.env['crm.team'].with_context(
-                    default_team_id=default_team_id,
-                )._get_default_team_id(
-                    user_id=user_id,
-                    domain=self.env['crm.team']._check_company_domain(company_id),
-                )
+                cached_teams[key] = self.env['crm.team'].with_context(default_team_id=default_team_id)._get_default_team_id(user_id=user_id, domain=self.env['crm.team']._check_company_domain(company_id))
             order.team_id = cached_teams[key]
 
     def _default_team_id(self):
@@ -514,11 +255,7 @@ class SaleOrder(models.Model):
             base_lines += order._add_base_lines_for_early_payment_discount()
             AccountTax._add_tax_details_in_base_lines(base_lines, order.company_id)
             AccountTax._round_base_lines_tax_details(base_lines, order.company_id)
-            tax_totals = AccountTax._get_tax_totals_summary(
-                base_lines=base_lines,
-                currency=order.currency_id or order.company_id.currency_id,
-                company=order.company_id,
-            )
+            tax_totals = AccountTax._get_tax_totals_summary(base_lines=base_lines, currency=order.currency_id or order.company_id.currency_id, company=order.company_id)
             order.amount_untaxed = tax_totals['base_amount_currency']
             order.amount_tax = tax_totals['tax_amount_currency']
             order.amount_total = tax_totals['total_amount_currency']
@@ -532,40 +269,17 @@ class SaleOrder(models.Model):
         """
         self.ensure_one()
         epd_lines = []
-        if (
-            self.payment_term_id.early_discount
-            and self.payment_term_id.early_pay_discount_computation == 'mixed'
-            and self.payment_term_id.discount_percentage
-        ):
+        if self.payment_term_id.early_discount and self.payment_term_id.early_pay_discount_computation == 'mixed' and self.payment_term_id.discount_percentage:
             percentage = self.payment_term_id.discount_percentage
             currency = self.currency_id or self.company_id.currency_id
             for line in self.order_line.filtered(lambda x: not x.display_type):
-                line_amount_after_discount = (line.price_subtotal / 100) * percentage
-                epd_lines.append(self.env['account.tax']._prepare_base_line_for_taxes_computation(
-                    record=self,
-                    price_unit=-line_amount_after_discount,
-                    quantity=1.0,
-                    currency_id=currency,
-                    sign=1,
-                    special_type='early_payment',
-                    tax_ids=line.tax_ids.flatten_taxes_hierarchy().filtered(lambda tax: tax.amount_type != 'fixed'),
-                ))
-                epd_lines.append(self.env['account.tax']._prepare_base_line_for_taxes_computation(
-                    record=self,
-                    price_unit=line_amount_after_discount,
-                    quantity=1.0,
-                    currency_id=currency,
-                    sign=1,
-                    special_type='early_payment',
-                ))
+                line_amount_after_discount = line.price_subtotal / 100 * percentage
+                epd_lines.append(self.env['account.tax']._prepare_base_line_for_taxes_computation(record=self, price_unit=-line_amount_after_discount, quantity=1.0, currency_id=currency, sign=1, special_type='early_payment', tax_ids=line.tax_ids.flatten_taxes_hierarchy().filtered(lambda tax: tax.amount_type != 'fixed')))
+                epd_lines.append(self.env['account.tax']._prepare_base_line_for_taxes_computation(record=self, price_unit=line_amount_after_discount, quantity=1.0, currency_id=currency, sign=1, special_type='early_payment'))
         return epd_lines
 
     @api.depends('order_line.invoice_lines')
     def _get_invoiced(self):
-        # The invoice_ids are obtained thanks to the invoice lines of the SO
-        # lines, and we also search for possible refunds created directly from
-        # existing invoices. This is necessary since such a refund is not
-        # directly linked to the SO.
         for order in self:
             invoices = order.order_line.invoice_lines.move_id.filtered(lambda r: r.move_type in ('out_invoice', 'out_refund'))
             order.invoice_ids = invoices
@@ -577,37 +291,13 @@ class SaleOrder(models.Model):
         if operator == 'in' and value:
             falsy_domain = []
             if False in value:
-                # special case for [('invoice_ids', '=', False)], i.e. "Invoices is not set"
-                #
-                # We cannot just search [('order_line.invoice_lines', '=', False)]
-                # because it returns orders with uninvoiced lines, which is not
-                # same "Invoices is not set" (some lines may have invoices and some
-                # don't)
-                #
-                # A solution is using the 'not any' operators with inverted search first
-                # ("orders with invoiced lines").
-                falsy_domain = [('order_line', 'not any', [
-                    ('invoice_lines.move_id.move_type', 'in', ('out_invoice', 'out_refund'))
-                ])]
+                falsy_domain = [('line_ids', 'not any', [('invoice_lines.move_id.move_type', 'in', ('out_invoice', 'out_refund'))])]
                 if len(value) == 1:
                     return falsy_domain
-            self.env.cr.execute("""
-                SELECT array_agg(so.id)
-                    FROM sale_order so
-                    JOIN sale_order_line sol ON sol.order_id = so.id
-                    JOIN sale_order_line_invoice_rel soli_rel ON soli_rel.order_line_id = sol.id
-                    JOIN account_move_line aml ON aml.id = soli_rel.invoice_line_id
-                    JOIN account_move am ON am.id = aml.move_id
-                WHERE
-                    am.move_type in ('out_invoice', 'out_refund') AND
-                    am.id = ANY(%s)
-            """, (list(value),))
+            self.env.cr.execute("\n                SELECT array_agg(so.id)\n                    FROM sale_order so\n                    JOIN sale_order_line sol ON sol.order_id = so.id\n                    JOIN sale_order_line_invoice_rel soli_rel ON soli_rel.order_line_id = sol.id\n                    JOIN account_move_line aml ON aml.id = soli_rel.invoice_line_id\n                    JOIN account_move am ON am.id = aml.move_id\n                WHERE\n                    am.move_type in ('out_invoice', 'out_refund') AND\n                    am.id = ANY(%s)\n            ", (list(value),))
             so_ids = self.env.cr.fetchone()[0] or []
             return [('id', 'in', so_ids)] + falsy_domain
-        return [('order_line.invoice_lines', 'any', [
-            ('move_id.move_type', 'in', ('out_invoice', 'out_refund')),
-            ('move_id', operator, value),
-        ])]
+        return [('order_line.invoice_lines', 'any', [('move_id.move_type', 'in', ('out_invoice', 'out_refund')), ('move_id', operator, value)])]
 
     @api.depends('state', 'order_line.invoice_status')
     def _compute_invoice_status(self):
@@ -624,35 +314,25 @@ class SaleOrder(models.Model):
         if not confirmed_orders:
             return
         lines_domain = [('is_downpayment', '=', False), ('display_type', '=', False)]
-        line_invoice_status_all = [
-            (order.id, invoice_status)
-            for order, invoice_status in self.env['sale.order.line']._read_group(
-                lines_domain + [('order_id', 'in', confirmed_orders.ids)],
-                ['order_id', 'invoice_status']
-            )
-        ]
+        line_invoice_status_all = [(order.id, invoice_status) for order, invoice_status in self.env['sale.order.line']._read_group(lines_domain + [('order_id', 'in', confirmed_orders.ids)], ['order_id', 'invoice_status'])]
         for order in confirmed_orders:
             line_invoice_status = [d[1] for d in line_invoice_status_all if d[0] == order.id]
             if order.state != 'sale':
                 order.invoice_status = 'no'
-            elif any(invoice_status == 'to invoice' for invoice_status in line_invoice_status):
-                if any(invoice_status == 'no' for invoice_status in line_invoice_status):
-                    # If only discount/delivery/promotion lines can be invoiced, the SO should not
-                    # be invoiceable.
-                    invoiceable_domain = lines_domain + [('invoice_status', '=', 'to invoice')]
+            elif any((invoice_status == 'to invoice' for invoice_status in line_invoice_status)):
+                if any((invoice_status == 'no' for invoice_status in line_invoice_status)):
+                    invoiceable_domain = lines_domain + [('invoice_state', '=', 'to invoice')]
                     invoiceable_lines = order.order_line.filtered_domain(invoiceable_domain)
-                    special_lines = invoiceable_lines.filtered(
-                        lambda sol: not sol._can_be_invoiced_alone()
-                    )
+                    special_lines = invoiceable_lines.filtered(lambda sol: not sol._can_be_invoiced_alone())
                     if invoiceable_lines == special_lines:
                         order.invoice_status = 'no'
                     else:
                         order.invoice_status = 'to invoice'
                 else:
                     order.invoice_status = 'to invoice'
-            elif line_invoice_status and all(invoice_status == 'invoiced' for invoice_status in line_invoice_status):
+            elif line_invoice_status and all((invoice_status == 'invoiced' for invoice_status in line_invoice_status)):
                 order.invoice_status = 'invoiced'
-            elif line_invoice_status and all(invoice_status in ('invoiced', 'upselling') for invoice_status in line_invoice_status):
+            elif line_invoice_status and all((invoice_status in ('invoiced', 'upselling') for invoice_status in line_invoice_status)):
                 order.invoice_status = 'upselling'
             else:
                 order.invoice_status = 'no'
@@ -667,15 +347,13 @@ class SaleOrder(models.Model):
     def _compute_amount_paid(self):
         """ Sum of the amount paid through all transactions for this SO. """
         for order in self:
-            order.amount_paid = sum(
-                tx.amount for tx in order.transaction_ids if tx.state in ('authorized', 'done')
-            )
+            order.amount_paid = sum((tx.amount for tx in order.transaction_ids if tx.state in ('authorized', 'done')))
 
     def _compute_amount_undiscounted(self):
         for order in self:
             total = 0.0
             for line in order.order_line:
-                total += (line.price_subtotal * 100)/(100-line.discount) if line.discount != 100 else (line.price_unit * line.product_uom_qty)
+                total += line.price_subtotal * 100 / (100 - line.discount) if line.discount != 100 else line.price_unit * line.product_uom_qty
             order.amount_undiscounted = total
 
     @api.depends('client_order_ref', 'origin', 'partner_id')
@@ -695,46 +373,21 @@ class SaleOrder(models.Model):
         orders = self.filtered(lambda order: order.id and order.client_order_ref)
         if not orders:
             return {}
-
         self.env['sale.order'].flush_model(['company_id', 'partner_id', 'client_order_ref', 'origin', 'state'])
-
-        result = self.env.execute_query(SQL("""
-            SELECT
-                sale_order.id AS order_id,
-                array_agg(duplicate_order.id) AS duplicate_ids
-              FROM sale_order
-              JOIN sale_order AS duplicate_order
-                ON sale_order.company_id = duplicate_order.company_id
-                 AND sale_order.id != duplicate_order.id
-                 AND duplicate_order.state != 'cancel'
-                 AND sale_order.partner_id = duplicate_order.partner_id
-                 AND (
-                    sale_order.origin = duplicate_order.name
-                    OR sale_order.client_order_ref = duplicate_order.client_order_ref
-                )
-             WHERE sale_order.id IN %(orders)s
-             GROUP BY sale_order.id
-            """,
-            orders=tuple(orders.ids),
-        ))
-        return {
-            order_id: set(duplicate_ids)
-            for order_id, duplicate_ids in result
-        }
+        result = self.env.execute_query(SQL("\n            SELECT\n                sale_order.id AS order_id,\n                array_agg(duplicate_order.id) AS duplicate_ids\n              FROM sale_order\n              JOIN sale_order AS duplicate_order\n                ON sale_order.company_id = duplicate_order.company_id\n                 AND sale_order.id != duplicate_order.id\n                 AND duplicate_order.state != 'cancel'\n                 AND sale_order.partner_id = duplicate_order.partner_id\n                 AND (\n                    sale_order.origin = duplicate_order.name\n                    OR sale_order.client_order_ref = duplicate_order.client_order_ref\n                )\n             WHERE sale_order.id IN %(orders)s\n             GROUP BY sale_order.id\n            ", orders=tuple(orders.ids)))
+        return {order_id: set(duplicate_ids) for order_id, duplicate_ids in result}
 
     @api.depends('order_line.customer_lead', 'date_order', 'state')
     def _compute_expected_date(self):
         """ For service and combo (non-goods) products, we avoid computing the expected date. This method is extended in sale_stock to
             take the picking_policy of SO into account.
         """
-        self.mapped("order_line")  # Prefetch indication
+        self.mapped('line_ids')
         for order in self:
             if order.state == 'cancel':
                 order.expected_date = False
                 continue
-            dates_list = order.order_line.filtered(
-                lambda line: line.product_id.type == 'consu' and not line.display_type and not line._is_delivery()
-            ).mapped(lambda line: line and line._expected_date())
+            dates_list = order.order_line.filtered(lambda line: line.product_id.type == 'consu' and (not line.display_type) and (not line._is_delivery())).mapped(lambda line: line and line._expected_date())
             if dates_list:
                 order.expected_date = order._select_expected_date(dates_list)
             else:
@@ -747,11 +400,7 @@ class SaleOrder(models.Model):
     def _compute_is_expired(self):
         today = fields.Date.today()
         for order in self:
-            order.is_expired = (
-                order.state in ('draft', 'sent')
-                and order.validity_date
-                and order.validity_date < today
-            )
+            order.is_expired = order.state in ('draft', 'sent') and order.validity_date and (order.validity_date < today)
 
     @api.depends('company_id', 'fiscal_position_id')
     def _compute_tax_country_id(self):
@@ -764,25 +413,21 @@ class SaleOrder(models.Model):
     @api.depends('order_line.amount_to_invoice')
     def _compute_amount_to_invoice(self):
         for order in self:
-            order.amount_to_invoice = sum(order.order_line.mapped('amount_to_invoice'))
+            order.amount_to_invoice = sum(order.order_line.mapped('amount_to_invoice_taxinc'))
 
     @api.depends('order_line.amount_invoiced')
     def _compute_amount_invoiced(self):
         for order in self:
-            order.amount_invoiced = sum(order.order_line.mapped('amount_invoiced'))
+            order.amount_invoiced = sum(order.order_line.mapped('amount_invoiced_taxinc'))
 
     @api.depends('company_id', 'partner_id', 'amount_total')
     def _compute_partner_credit_warning(self):
         for order in self:
             order.with_company(order.company_id)
             order.partner_credit_warning = ''
-            show_warning = order.state in ('draft', 'sent') and \
-                           order.company_id.account_use_credit_limit
+            show_warning = order.state in ('draft', 'sent') and order.company_id.account_use_credit_limit
             if show_warning:
-                order.partner_credit_warning = self.env['account.move']._build_credit_warning_message(
-                    order.sudo(),  # ensure access to `credit` & `credit_limit` fields
-                    current_amount=(order.amount_total / order.currency_rate),
-                )
+                order.partner_credit_warning = self.env['account.move']._build_credit_warning_message(order.sudo(), current_amount=order.amount_total / order.currency_rate)
 
     @api.depends_context('lang')
     @api.depends('order_line.price_subtotal', 'currency_id', 'company_id', 'payment_term_id')
@@ -794,21 +439,16 @@ class SaleOrder(models.Model):
             base_lines += order._add_base_lines_for_early_payment_discount()
             AccountTax._add_tax_details_in_base_lines(base_lines, order.company_id)
             AccountTax._round_base_lines_tax_details(base_lines, order.company_id)
-            order.tax_totals = AccountTax._get_tax_totals_summary(
-                base_lines=base_lines,
-                currency=order.currency_id or order.company_id.currency_id,
-                company=order.company_id,
-            )
+            order.tax_totals = AccountTax._get_tax_totals_summary(base_lines=base_lines, currency=order.currency_id or order.company_id.currency_id, company=order.company_id)
 
     @api.depends('state')
     def _compute_type_name(self):
         for record in self:
             if record.state in ('draft', 'sent', 'cancel'):
-                record.type_name = _("Quotation")
+                record.type_name = _('Quotation')
             else:
-                record.type_name = _("Sales Order")
+                record.type_name = _('Sales Order')
 
-    # portal.mixin override
     def _compute_access_url(self):
         super()._compute_access_url()
         for order in self:
@@ -818,62 +458,38 @@ class SaleOrder(models.Model):
     def _compute_sale_warning_text(self):
         for order in self:
             warnings = OrderedSet()
-            if partner_msg := order.partner_id.sale_warn_msg:
+            if (partner_msg := order.partner_id.sale_warn_msg):
                 warnings.add(order.partner_id.name + ' - ' + partner_msg)
             for line in order.order_line:
-                if product_msg := line.sale_line_warn_msg:
+                if (product_msg := line.sale_line_warn_msg):
                     warnings.add(line.product_id.display_name + ' - ' + product_msg)
             order.sale_warning_text = '\n'.join(warnings)
 
-    #=== CONSTRAINT METHODS ===#
-
     @api.constrains('company_id', 'order_line')
     def _check_order_line_company_id(self):
         for order in self:
-            invalid_companies = order.order_line.product_id.company_id.filtered(
-                lambda c: order.company_id not in c._accessible_branches()
-            )
+            invalid_companies = order.order_line.product_id.company_id.filtered(lambda c: order.company_id not in c._accessible_branches())
             if invalid_companies:
-                bad_products = order.order_line.product_id.filtered(
-                    lambda p: p.company_id and p.company_id in invalid_companies
-                )
-                raise ValidationError(_(
-                    "Your quotation contains products from company %(product_company)s whereas your quotation belongs to company %(quote_company)s. \n Please change the company of your quotation or remove the products from other companies (%(bad_products)s).",
-                    product_company=', '.join(invalid_companies.sudo().mapped('display_name')),
-                    quote_company=order.company_id.display_name,
-                    bad_products=', '.join(bad_products.mapped('display_name')),
-                ))
+                bad_products = order.order_line.product_id.filtered(lambda p: p.company_id and p.company_id in invalid_companies)
+                raise ValidationError(_('Your quotation contains products from company %(product_company)s whereas your quotation belongs to company %(quote_company)s. \n Please change the company of your quotation or remove the products from other companies (%(bad_products)s).', product_company=', '.join(invalid_companies.sudo().mapped('display_name')), quote_company=order.company_id.display_name, bad_products=', '.join(bad_products.mapped('display_name'))))
 
     @api.constrains('prepayment_percent')
     def _check_prepayment_percent(self):
         for order in self:
-            if order.require_payment and not (0 < order.prepayment_percent <= 1.0):
-                raise ValidationError(_("Prepayment percentage must be a valid percentage."))
-
-    #=== ONCHANGE METHODS ===#
+            if order.require_payment and (not 0 < order.prepayment_percent <= 1.0):
+                raise ValidationError(_('Prepayment percentage must be a valid percentage.'))
 
     def onchange(self, values, field_names, fields_spec):
         self_with_context = self
         if not field_names:
-            self_with_context = self.with_context(
-                # Some warnings should not be displayed for the first onchange
-                sale_onchange_first_call=True,
-                # invoice & delivery address with higher `customer_rank` should take priority
-                res_partner_search_mode='customer',
-            )
+            self_with_context = self.with_context(sale_onchange_first_call=True, res_partner_search_mode='customer')
         return super(SaleOrder, self_with_context).onchange(values, field_names, fields_spec)
 
-    @api.onchange('commitment_date', 'expected_date')
-    def _onchange_commitment_date(self):
+    @api.onchange('date_commitment', 'expected_date')
+    def _onchange_date_commitment(self):
         """ Warn if the commitment dates is sooner than the expected date """
-        if self.commitment_date and self.expected_date and self.commitment_date < self.expected_date:
-            return {
-                'warning': {
-                    'title': _('Requested date is too soon.'),
-                    'message': _("The delivery date is sooner than the expected date."
-                                 " You may be unable to honor the delivery date.")
-                }
-            }
+        if self.commitment_date and self.expected_date and (self.commitment_date < self.expected_date):
+            return {'warning': {'title': _('Requested date is too soon.'), 'message': _('The delivery date is sooner than the expected date. You may be unable to honor the delivery date.')}}
 
     @api.onchange('company_id')
     def _onchange_company_id_warning(self):
@@ -881,29 +497,17 @@ class SaleOrder(models.Model):
         if self.env.context.get('sale_onchange_first_call'):
             return
         if self.order_line and self.state == 'draft':
-            return {
-                'warning': {
-                    'title': _("Warning for the change of your quotation's company"),
-                    'message': _("Changing the company of an existing quotation might need some "
-                                 "manual adjustments in the details of the lines. You might "
-                                 "consider updating the prices."),
-                }
-            }
+            return {'warning': {'title': _("Warning for the change of your quotation's company"), 'message': _('Changing the company of an existing quotation might need some manual adjustments in the details of the lines. You might consider updating the prices.')}}
 
     @api.onchange('company_id')
     def _onchange_company_id(self):
         for order in self:
-            # This can't be caught by a python constraint as it is only triggered at save
-            # and a compute methodd needs this data to be set correctly before saving
             if not order.company_id:
-                raise ValidationError(_("The company is required, please select one before making any other changes to the sale order."))
+                raise ValidationError(_('The company is required, please select one before making any other changes to the sale order.'))
 
     @api.onchange('fiscal_position_id')
     def _onchange_fpos_id_show_update_fpos(self):
-        if self.order_line and (
-            not self.fiscal_position_id
-            or (self.fiscal_position_id and self._origin.fiscal_position_id != self.fiscal_position_id)
-        ):
+        if self.order_line and (not self.fiscal_position_id or (self.fiscal_position_id and self._origin.fiscal_position_id != self.fiscal_position_id)):
             self.show_update_fpos = True
 
     @api.onchange('pricelist_id')
@@ -915,7 +519,7 @@ class SaleOrder(models.Model):
         if not self.prepayment_percent:
             self.require_payment = False
 
-    @api.onchange('order_line')
+    @api.onchange('line_ids')
     def _onchange_order_line(self):
         for index, line in enumerate(self.order_line):
             if line.product_type != 'combo':
@@ -923,169 +527,76 @@ class SaleOrder(models.Model):
             combo_item_lines = line._get_linked_lines().filtered('combo_item_id')
             if line.selected_combo_items:
                 selected_combo_items = json.loads(line.selected_combo_items)
-                if (
-                    selected_combo_items
-                    and len(selected_combo_items) != len(line.product_template_id.sudo().combo_ids)
-                ):
-                    raise ValidationError(_(
-                        "The number of selected combo items must match the number of available"
-                        " combo choices."
-                    ))
-
-                # Delete any existing combo item lines.
+                if selected_combo_items and len(selected_combo_items) != len(line.product_template_id.sudo().combo_ids):
+                    raise ValidationError(_('The number of selected combo items must match the number of available combo choices.'))
                 delete_commands = [Command.delete(linked_line.id) for linked_line in combo_item_lines]
-                # Create a new combo item line for each selected combo item.
-                create_commands = [Command.create({
-                    'product_id': combo_item['product_id'],
-                    'product_uom_qty': line.product_uom_qty,
-                    'combo_item_id': combo_item['combo_item_id'],
-                    'product_no_variant_attribute_value_ids': [
-                        Command.set(combo_item['no_variant_attribute_value_ids'])
-                    ],
-                    'product_custom_attribute_value_ids': [Command.clear()] + [
-                        Command.create(attribute_value)
-                        for attribute_value in combo_item['product_custom_attribute_values']
-                    ],
-                    # Combo item lines should come directly after their combo product line.
-                    'sequence': line.sequence + item_index + 1,
-                    # If the linked line exists in DB, populate linked_line_id, otherwise populate
-                    # linked_virtual_id.
-                    'linked_line_id': line.id if line._origin else False,
-                    'linked_virtual_id': line.virtual_id if not line._origin else False,
-                }) for item_index, combo_item in enumerate(selected_combo_items)]
-                # Shift any lines coming after the combo product line so that the combo item lines
-                # come first.
-                update_commands = [Command.update(
-                    order_line.id,
-                    {'sequence': order_line.sequence + len(selected_combo_items)},
-                ) for order_line in self.order_line if order_line.sequence > line.sequence]
-
-                # Clear `selected_combo_items` to avoid applying the same changes multiple times.
+                create_commands = [Command.create({'product_id': combo_item['product_id'], 'product_uom_qty': line.product_uom_qty, 'combo_item_id': combo_item['combo_item_id'], 'product_no_variant_attribute_value_ids': [Command.set(combo_item['no_variant_attribute_value_ids'])], 'product_custom_attribute_value_ids': [Command.clear()] + [Command.create(attribute_value) for attribute_value in combo_item['product_custom_attribute_values']], 'sequence': line.sequence + item_index + 1, 'linked_line_id': line.id if line._origin else False, 'linked_virtual_id': line.virtual_id if not line._origin else False}) for item_index, combo_item in enumerate(selected_combo_items)]
+                update_commands = [Command.update(order_line.id, {'sequence': order_line.sequence + len(selected_combo_items)}) for order_line in self.order_line if order_line.sequence > line.sequence]
                 line.selected_combo_items = False
                 self.order_line = delete_commands + create_commands + update_commands
             elif combo_item_lines:
-                combo_item_lines.update({
-                    'product_uom_qty': line.product_uom_qty,
-                    'discount': line.discount,
-                })
-
-    #=== CRUD METHODS ===#
+                combo_item_lines.update({'product_uom_qty': line.product_uom_qty, 'discount': line.discount})
 
     @api.model_create_multi
     def create(self, vals_list):
         for vals in vals_list:
-            if vals.get('name', _("New")) == _("New"):
-                seq_date = fields.Datetime.context_timestamp(
-                    self, fields.Datetime.to_datetime(vals['date_order'])
-                ) if 'date_order' in vals else None
-                vals['name'] = self.env['ir.sequence'].with_company(vals.get('company_id')).next_by_code(
-                    'sale.order', sequence_date=seq_date) or _("New")
-
+            if vals.get('name', _('New')) == _('New'):
+                seq_date = fields.Datetime.context_timestamp(self, fields.Datetime.to_datetime(vals['date_order'])) if 'date_order' in vals else None
+                vals['name'] = self.env['ir.sequence'].with_company(vals.get('company_id')).next_by_code('sale.order', sequence_date=seq_date) or _('New')
         return super().create(vals_list)
 
-    def _get_copiable_order_lines(self):
+    def _get_order_lines_copiable(self):
         """Returns the order lines that can be copied to a new order."""
         return self.order_line.filtered(lambda l: not l.is_downpayment)
 
     def copy_data(self, default=None):
         default = dict(default or {})
         default_has_no_order_line = 'order_line' not in default
-        default.setdefault('order_line', [])
+        default.setdefault('line_ids', [])
         vals_list = super().copy_data(default=default)
         if default_has_no_order_line:
             for order, vals in zip(self, vals_list):
-                vals['order_line'] = [
-                    Command.create(line_vals)
-                    for line_vals in order._get_copiable_order_lines().copy_data()
-                ]
+                vals['order_line'] = [Command.create(line_vals) for line_vals in order._get_copiable_order_lines().copy_data()]
         return vals_list
 
     @api.ondelete(at_uninstall=False)
     def _unlink_except_draft_or_cancel(self):
         for order in self:
             if order.state not in ('draft', 'cancel'):
-                raise UserError(_(
-                    "You can not delete a sent quotation or a confirmed sales order."
-                    " You must first cancel it."))
+                raise UserError(_('You can not delete a sent quotation or a confirmed sales order. You must first cancel it.'))
 
     def write(self, vals):
-        if 'pricelist_id' in vals and any(so.state == 'sale' for so in self):
-            raise UserError(_("You cannot change the pricelist of a confirmed order !"))
+        if 'pricelist_id' in vals and any((so.state == 'sale' for so in self)):
+            raise UserError(_('You cannot change the pricelist of a confirmed order !'))
         return super().write(vals)
 
-    #=== ACTION METHODS ===#
-
     @api.readonly
     def action_open_discount_wizard(self):
         self.ensure_one()
-        return {
-            'name': _("Discount"),
-            'type': 'ir.actions.act_window',
-            'res_model': 'sale.order.discount',
-            'view_mode': 'form',
-            'target': 'new',
-        }
+        return {'name': _('Discount'), 'type': 'ir.actions.act_window', 'res_model': 'sale.order.discount', 'view_mode': 'form', 'target': 'new'}
 
     def action_draft(self):
         orders = self.filtered(lambda s: s.state in ['cancel', 'sent'])
-        return orders.write({
-            'state': 'draft',
-            'signature': False,
-            'signed_by': False,
-            'signed_on': False,
-        })
-
-    def action_quotation_send(self):
+        return orders.write({'state': 'draft', 'signature': False, 'signed_by': False, 'signed_on': False})
+
+    def action_send_quotation(self):
         """ Opens a wizard to compose an email, with relevant mail template loaded by default """
         self.filtered(lambda so: so.state in ('draft', 'sent')).order_line._validate_analytic_distribution()
-
-        ctx = {
-            'default_model': 'sale.order',
-            'default_res_ids': self.ids,
-            'default_composition_mode': 'comment',
-            'default_email_layout_xmlid': 'mail.mail_notification_layout_with_responsible_signature',
-            'email_notification_allow_footer': True,
-            'hide_mail_template_management_options': True,
-            'proforma': self.env.context.get('proforma', False),
-        }
-
+        ctx = {'default_model': 'sale.order', 'default_res_ids': self.ids, 'default_composition_mode': 'comment', 'default_email_layout_xmlid': 'mail.mail_notification_layout_with_responsible_signature', 'email_notification_allow_footer': True, 'hide_mail_template_management_options': True, 'proforma': self.env.context.get('proforma', False)}
         if len(self) > 1:
             ctx['default_composition_mode'] = 'mass_mail'
         else:
-            ctx.update({
-                'force_email': True,
-            })
+            ctx.update({'force_email': True})
             if not self.env.context.get('hide_default_template'):
                 mail_template = self._find_mail_template()
                 if mail_template:
-                    ctx.update({
-                        'default_template_id': mail_template.id,
-                        'mark_so_as_sent': True,
-                    })
+                    ctx.update({'default_template_id': mail_template.id, 'mark_so_as_sent': True})
             else:
                 for order in self:
                     order._portal_ensure_token()
-
-        action = {
-            'name': _('Send'),
-            'type': 'ir.actions.act_window',
-            'view_mode': 'form',
-            'res_model': 'mail.compose.message',
-            'views': [(False, 'form')],
-            'view_id': False,
-            'target': 'new',
-            'context': ctx,
-        }
-        if (
-            self.env.context.get('check_document_layout')
-            and not self.env.context.get('discard_logo_check')
-            and self.env.is_admin()
-            and not self.env.company.external_report_layout_id
-        ):
-            layout_action = self.env['ir.actions.report']._action_configure_external_report_layout(
-                action,
-            )
-            # Need to remove this context for windows action
+        action = {'name': _('Send'), 'type': 'ir.actions.act_window', 'view_mode': 'form', 'res_model': 'mail.compose.message', 'views': [(False, 'form')], 'view_id': False, 'target': 'new', 'context': ctx}
+        if self.env.context.get('check_document_layout') and (not self.env.context.get('discard_logo_check')) and self.env.is_admin() and (not self.env.company.external_report_layout_id):
+            layout_action = self.env['ir.actions.report']._action_configure_external_report_layout(action)
             action.pop('close_on_report_download', None)
             layout_action['context']['dialog_size'] = 'extra-large'
             return layout_action
@@ -1114,11 +625,8 @@ class SaleOrder(models.Model):
         :return: `mail.template` record or None if default template wasn't found
         """
         self.ensure_one()
-        default_confirmation_template_id = self.env['ir.config_parameter'].sudo().get_param(
-            'sale.default_confirmation_template'
-        )
-        default_confirmation_template = default_confirmation_template_id \
-            and self.env['mail.template'].browse(int(default_confirmation_template_id)).exists()
+        default_confirmation_template_id = self.env['ir.config_parameter'].sudo().get_param('sale.default_confirmation_template')
+        default_confirmation_template = default_confirmation_template_id and self.env['mail.template'].browse(int(default_confirmation_template_id)).exists()
         if default_confirmation_template:
             return default_confirmation_template
         else:
@@ -1129,9 +637,8 @@ class SaleOrder(models.Model):
 
         :raise: UserError if any given SO is not in draft state.
         """
-        if any(order.state != 'draft' for order in self):
-            raise UserError(_("Only draft orders can be marked as sent directly."))
-
+        if any((order.state != 'draft' for order in self)):
+            raise UserError(_('Only draft orders can be marked as sent directly.'))
         self.write({'state': 'sent'})
 
     def action_confirm(self):
@@ -1147,43 +654,28 @@ class SaleOrder(models.Model):
             error_msg = order._confirmation_error_message()
             if error_msg:
                 raise UserError(error_msg)
-
         self.order_line._validate_analytic_distribution()
-
         self.write(self._prepare_confirmation_values())
-
-        # Context key 'default_name' is sometimes propagated up to here.
-        # We don't need it and it creates issues in the creation of linked records.
         context = self.env.context.copy()
         context.pop('default_name', None)
         context.pop('default_user_id', None)
-
         self.with_context(context)._action_confirm()
         self.filtered(lambda so: so._should_be_locked()).action_lock()
-
         if self.env.context.get('send_email'):
             self._send_order_confirmation_mail()
-
         return True
 
     def _should_be_locked(self):
         self.ensure_one()
-        # Public user can confirm SO, so we check the group on any record creator.
         return self.env['res.groups']._is_feature_enabled('sale.group_auto_done_setting')
 
     def _confirmation_error_message(self):
         """ Return whether order can be confirmed or not if not then returm error message. """
         self.ensure_one()
         if self.state not in {'draft', 'sent'}:
-            return _("Some orders are not in a state requiring confirmation.")
-        if any(
-            not line.display_type
-            and not line.is_downpayment
-            and not line.product_id
-            for line in self.order_line
-        ):
-            return _("Some order lines are missing a product, you need to correct them before going further.")
-
+            return _('Some orders are not in a state requiring confirmation.')
+        if any((not line.display_type and (not line.is_downpayment) and (not line.product_id) for line in self.order_line)):
+            return _('Some order lines are missing a product, you need to correct them before going further.')
         return False
 
     def _prepare_confirmation_values(self):
@@ -1194,10 +686,7 @@ class SaleOrder(models.Model):
         :return: Sales Order confirmation values
         :rtype: dict
         """
-        return {
-            'state': 'sale',
-            'date_order': fields.Datetime.now()
-        }
+        return {'state': 'sale', 'date_order': fields.Datetime.now()}
 
     def _action_confirm(self):
         """ Implementation of additional mechanism of Sales Order confirmation.
@@ -1219,9 +708,7 @@ class SaleOrder(models.Model):
 
         :return: None
         """
-        mail_template = self.env.ref(
-            'sale.mail_template_sale_payment_executed', raise_if_not_found=False
-        )
+        mail_template = self.env.ref('sale.mail_template_sale_payment_executed', raise_if_not_found=False)
         for order in self:
             order._send_order_notification_mail(mail_template)
 
@@ -1238,28 +725,18 @@ class SaleOrder(models.Model):
         :return: None
         """
         self.ensure_one()
-
         if not mail_template:
             return
-
         if self.env.su:
-            # sending mail in sudo was meant for it being sent from superuser
             self = self.with_user(SUPERUSER_ID)
-
         async_send = str2bool(self.env['ir.config_parameter'].sudo().get_param('sale.async_emails'))
         cron = self.env.ref('sale.send_pending_emails_cron', raise_if_not_found=False)
         cron_enabled = cron and cron.sudo().active
         if async_send and cron_enabled and allow_deferred_sending:
-            # Schedule the email to be sent asynchronously.
             self.pending_email_template_id = mail_template
             cron._trigger()
-        else:  # Async emails are disabled, either by the user or we are in the cron job.
-            # Send the email synchronously.
-            self.with_context(force_send=True).message_post_with_source(
-                mail_template,
-                email_layout_xmlid='mail.mail_notification_layout_with_responsible_signature',
-                subtype_xmlid='mail.mt_comment',
-            )
+        else:
+            self.with_context(force_send=True).message_post_with_source(mail_template, email_layout_xmlid='mail.mail_notification_layout_with_responsible_signature', subtype_xmlid='mail.mt_comment')
 
     def _validate_order(self):
         """Confirm the sale order and send a confirmation email.
@@ -1277,10 +754,8 @@ class SaleOrder(models.Model):
         pending_email_orders = self.search([('pending_email_template_id', '!=', False)])
         self.env['ir.cron']._commit_progress(remaining=len(pending_email_orders))
         for order in pending_email_orders:
-            order = order[0]  # Avoid pre-fetching after each cache invalidation due to committing.
-            order._send_order_notification_mail(
-                order.pending_email_template_id, allow_deferred_sending=False
-            )  # Resume the email sending.
+            order = order[0]
+            order._send_order_notification_mail(order.pending_email_template_id, allow_deferred_sending=False)
             order.pending_email_template_id = None
             remaining_time = self.env['ir.cron']._commit_progress(processed=1)
             if not remaining_time:
@@ -1294,8 +769,8 @@ class SaleOrder(models.Model):
 
     def action_cancel(self):
         """ Cancel sales order and related draft invoices. """
-        if any(order.locked for order in self):
-            raise UserError(_("You cannot cancel a locked order. Please unlock it first."))
+        if any((order.locked for order in self)):
+            raise UserError(_('You cannot cancel a locked order. Please unlock it first.'))
         return self._action_cancel()
 
     def _action_cancel(self):
@@ -1306,21 +781,13 @@ class SaleOrder(models.Model):
     @api.readonly
     def action_preview_sale_order(self):
         self.ensure_one()
-        return {
-            'type': 'ir.actions.act_url',
-            'target': 'self',
-            'url': self.get_portal_url(),
-        }
+        return {'type': 'ir.actions.act_url', 'target': 'self', 'url': self.get_portal_url()}
 
     def action_update_taxes(self):
         self.ensure_one()
-
         self._recompute_taxes()
-
         if self.partner_id:
-            self.message_post(body=_("Product taxes have been recomputed according to fiscal position %s.",
-                self.fiscal_position_id._get_html_link() if self.fiscal_position_id else "")
-            )
+            self.message_post(body=_('Product taxes have been recomputed according to fiscal position %s.', self.fiscal_position_id._get_html_link() if self.fiscal_position_id else ''))
 
     def _recompute_taxes(self):
         lines_to_recompute = self.order_line.filtered(lambda line: not line.display_type)
@@ -1329,23 +796,17 @@ class SaleOrder(models.Model):
 
     def action_update_prices(self):
         self.ensure_one()
-
         self._recompute_prices()
-
         if self.pricelist_id:
-            message = _("Product prices have been recomputed according to pricelist %s.",
-                self.pricelist_id._get_html_link())
+            message = _('Product prices have been recomputed according to pricelist %s.', self.pricelist_id._get_html_link())
         else:
-            message = _("Product prices have been recomputed.")
+            message = _('Product prices have been recomputed.')
         self.message_post(body=message)
 
     def _recompute_prices(self):
         lines_to_recompute = self._get_update_prices_lines()
         lines_to_recompute.invalidate_recordset(['pricelist_item_id'])
         lines_to_recompute.with_context(force_price_recomputation=True)._compute_price_unit()
-        # Special case: we want to overwrite the existing discount on _recompute_prices call
-        # i.e. to make sure the discount is correctly reset
-        # if pricelist rule is different than when the price was first computed.
         lines_to_recompute.discount = 0.0
         lines_to_recompute._compute_discount()
         self.show_update_pricelist = False
@@ -1356,12 +817,7 @@ class SaleOrder(models.Model):
         return {**default_data, **new_default_data}
 
     def _get_action_add_from_catalog_extra_context(self):
-        return {
-            **super()._get_action_add_from_catalog_extra_context(),
-            'product_catalog_currency_id': self.currency_id.id,
-            'product_catalog_digits': self.order_line._fields['price_unit'].get_digits(self.env),
-            'show_sections': bool(self.id),
-        }
+        return {**super()._get_action_add_from_catalog_extra_context(), 'product_catalog_currency_id': self.currency_id.id, 'product_catalog_digits': self.order_line._fields['price_unit'].get_digits(self.env), 'show_sections': bool(self.id)}
 
     def _get_product_catalog_domain(self):
         return super()._get_product_catalog_domain() & Domain('sale_ok', '=', True)
@@ -1369,15 +825,7 @@ class SaleOrder(models.Model):
     @api.readonly
     def action_open_business_doc(self):
         self.ensure_one()
-        return {
-            'name': _("Order"),
-            'type': 'ir.actions.act_window',
-            'res_model': 'sale.order',
-            'res_id': self.id,
-            'views': [(False, 'form')],
-        }
-
-    # INVOICING #
+        return {'name': _('Order'), 'type': 'ir.actions.act_window', 'res_model': 'sale.order', 'res_id': self.id, 'views': [(False, 'form')]}
 
     def _prepare_invoice(self):
         """
@@ -1386,36 +834,8 @@ class SaleOrder(models.Model):
         a clean extension chain).
         """
         self.ensure_one()
-
-        txs_to_be_linked = self.sudo().transaction_ids.filtered(
-            lambda tx: (
-                tx.state in ('pending', 'authorized')
-                or (tx.state == 'done' and not tx.payment_id.is_reconciled)
-            )
-        )
-
-        values = {
-            'ref': self.client_order_ref or '',
-            'move_type': 'out_invoice',
-            'narration': self.note,
-            'currency_id': self.currency_id.id,
-            'campaign_id': self.campaign_id.id,
-            'medium_id': self.medium_id.id,
-            'source_id': self.source_id.id,
-            'team_id': self.team_id.id,
-            'partner_id': self.partner_invoice_id.id,
-            'partner_shipping_id': self.partner_shipping_id.id,
-            'fiscal_position_id': (self.fiscal_position_id or self.fiscal_position_id._get_fiscal_position(self.partner_invoice_id)).id,
-            'invoice_origin': self.name,
-            'invoice_payment_term_id': self.payment_term_id.id,
-            'preferred_payment_method_line_id': self.preferred_payment_method_line_id.id,
-            'invoice_user_id': self.user_id.id,
-            'payment_reference': self.reference,
-            'transaction_ids': [Command.set(txs_to_be_linked.ids)],
-            'company_id': self.company_id.id,
-            'invoice_line_ids': [],
-            'user_id': self.user_id.id,
-        }
+        txs_to_be_linked = self.sudo().transaction_ids.filtered(lambda tx: tx.state in ('pending', 'authorized') or (tx.state == 'done' and (not tx.payment_id.is_reconciled)))
+        values = {'ref': self.client_order_ref or '', 'move_type': 'out_invoice', 'narration': self.note, 'currency_id': self.currency_id.id, 'campaign_id': self.campaign_id.id, 'medium_id': self.medium_id.id, 'source_id': self.source_id.id, 'team_id': self.team_id.id, 'partner_id': self.partner_invoice_id.id, 'partner_shipping_id': self.partner_shipping_id.id, 'fiscal_position_id': (self.fiscal_position_id or self.fiscal_position_id._get_fiscal_position(self.partner_invoice_id)).id, 'invoice_origin': self.name, 'invoice_payment_term_id': self.payment_term_id.id, 'preferred_payment_method_line_id': self.preferred_payment_method_line_id.id, 'invoice_user_id': self.user_id.id, 'payment_reference': self.reference, 'transaction_ids': [Command.set(txs_to_be_linked.ids)], 'company_id': self.company_id.id, 'invoice_line_ids': [], 'user_id': self.user_id.id}
         if self.journal_id:
             values['journal_id'] = self.journal_id.id
         return values
@@ -1430,23 +850,15 @@ class SaleOrder(models.Model):
         elif len(invoices) == 1:
             form_view = [(self.env.ref('account.view_move_form').id, 'form')]
             if 'views' in action:
-                action['views'] = form_view + [(state,view) for state,view in action['views'] if view != 'form']
+                action['views'] = form_view + [(state, view) for state, view in action['views'] if view != 'form']
             else:
                 action['views'] = form_view
             action['res_id'] = invoices.id
         else:
             action = {'type': 'ir.actions.act_window_close'}
-
-        context = {
-            'default_move_type': 'out_invoice',
-        }
+        context = {'default_move_type': 'out_invoice'}
         if len(self) == 1:
-            context.update({
-                'default_partner_id': self.partner_id.id,
-                'default_partner_shipping_id': self.partner_shipping_id.id,
-                'default_invoice_payment_term_id': self.payment_term_id.id or self.partner_id.property_payment_term_id.id or self.env['account.move'].default_get(['invoice_payment_term_id']).get('invoice_payment_term_id'),
-                'default_invoice_origin': self.name,
-            })
+            context.update({'default_partner_id': self.partner_id.id, 'default_partner_shipping_id': self.partner_shipping_id.id, 'default_invoice_payment_term_id': self.payment_term_id.id or self.partner_id.property_payment_term_id.id or self.env['account.move'].default_get(['invoice_payment_term_id']).get('invoice_payment_term_id'), 'default_invoice_origin': self.name})
         action['context'] = context
         return action
 
@@ -1454,15 +866,7 @@ class SaleOrder(models.Model):
         return ['company_id', 'partner_id', 'partner_shipping_id', 'currency_id']
 
     def _nothing_to_invoice_error_message(self):
-        return _(
-            "Cannot create an invoice. No items are available to invoice.\n\n"
-            "To resolve this issue, please ensure that:\n"
-            "   \u2022 The products have been delivered before attempting to invoice them.\n"
-            "   \u2022 The invoicing policy of the product is configured correctly.\n\n"
-            "If you want to invoice based on ordered quantities instead:\n"
-            "   \u2022 For consumable or storable products, open the product, go to the 'General Information' tab and change the 'Invoicing Policy' from 'Delivered Quantities' to 'Ordered Quantities'.\n"
-            "   \u2022 For services (and other products), change the 'Invoicing Policy' to 'Prepaid/Fixed Price'.\n"
-        )
+        return _("Cannot create an invoice. No items are available to invoice.\n\nTo resolve this issue, please ensure that:\n    The products have been delivered before attempting to invoice them.\n    The invoicing policy of the product is configured correctly.\n\nIf you want to invoice based on ordered quantities instead:\n    For consumable or storable products, open the product, go to the 'General Information' tab and change the 'Invoicing Policy' from 'Delivered Quantities' to 'Ordered Quantities'.\n    For services (and other products), change the 'Invoicing Policy' to 'Prepaid/Fixed Price'.\n")
 
     def _get_update_prices_lines(self):
         """ Hook to exclude specific lines which should not be updated based on price list recomputation """
@@ -1475,33 +879,27 @@ class SaleOrder(models.Model):
         section_line_ids = []
         subsection_line_ids = []
         precision = self.env['decimal.precision'].precision_get('Product Unit')
-
         for line in self.order_line:
             if line.display_type == 'line_section':
-                section_line_ids = [line.id]  # Start a new section.
+                section_line_ids = [line.id]
                 subsection_line_ids = []
                 continue
             if line.display_type == 'line_subsection':
-                subsection_line_ids = [line.id]  # Start a new subsection.
+                subsection_line_ids = [line.id]
                 continue
             if line.display_type != 'line_note' and float_is_zero(line.qty_to_invoice, precision_digits=precision):
                 continue
             if line.qty_to_invoice > 0 or (line.qty_to_invoice < 0 and final) or line.display_type == 'line_note':
                 if line.is_downpayment:
-                    # Keep down payment lines separately, to put them together
-                    # at the end of the invoice, in a specific dedicated section.
                     down_payment_line_ids.append(line.id)
                     continue
-                # If the invoicable line is under subsection
                 if subsection_line_ids:
                     if line.display_type:
                         subsection_line_ids.append(line.id)
                         continue
-                    # Extend the subsection lines too if altleast one invoicable line is under subsection
                     invoiceable_line_ids.extend(section_line_ids + subsection_line_ids)
                     subsection_line_ids = []
                     section_line_ids = []
-                # If the invoicable line is under section
                 elif section_line_ids:
                     if line.display_type:
                         section_line_ids.append(line.id)
@@ -1510,13 +908,10 @@ class SaleOrder(models.Model):
                     section_line_ids = []
                     subsection_line_ids = []
                 invoiceable_line_ids.append(line.id)
-
         return self.env['sale.order.line'].browse(invoiceable_line_ids + down_payment_line_ids)
 
     def _create_account_invoices(self, invoice_vals_list, final):
         """Small method to allow overriding the behavior right after an invoice is created."""
-        # Manage the creation of invoices in sudo because a salesperson must be able to generate an invoice from a
-        # sale order without "billing" access rights. However, he should not be able to create an invoice from scratch.
         return self.env['account.move'].sudo().with_context(default_move_type='out_invoice').create(invoice_vals_list)
 
     def _create_invoices(self, grouped=False, final=False, date=None):
@@ -1535,67 +930,38 @@ class SaleOrder(models.Model):
                 self.check_access('write')
             except AccessError:
                 return self.env['account.move']
-
-        # 1) Create invoices.
         invoice_vals_list = []
-        invoice_item_sequence = 0 # Incremental sequencing to keep the lines order on the invoice.
+        invoice_item_sequence = 0
         for order in self:
             if order.partner_invoice_id.lang:
                 order = order.with_context(lang=order.partner_invoice_id.lang)
             order = order.with_company(order.company_id)
-
             invoice_vals = order._prepare_invoice()
             invoiceable_lines = order._get_invoiceable_lines(final)
-
-            if all(line.display_type for line in invoiceable_lines):
+            if all((line.display_type for line in invoiceable_lines)):
                 continue
-
             invoice_line_vals = []
             down_payment_section_added = False
             for line in invoiceable_lines:
                 if not down_payment_section_added and line.is_downpayment:
-                    # Create a dedicated section for the down payments
-                    # (put at the end of the invoiceable_lines)
-                    invoice_line_vals.append(
-                        Command.create(
-                            order._prepare_down_payment_section_line(sequence=invoice_item_sequence)
-                        ),
-                    )
+                    invoice_line_vals.append(Command.create(order._prepare_down_payment_section_line(sequence=invoice_item_sequence)))
                     down_payment_section_added = True
                     invoice_item_sequence += 1
-
                 optional_values = {'sequence': invoice_item_sequence}
-
-                # When creating the final invoice, we want to express the lines representing
-                # the full order but negate the already created down payment lines.
-                # At this point, on the sale order, the down payment lines have a non-empty
-                # 'extra_tax_data' containing a price unit greater than zero and a quantity of 0.0.
                 if line.is_downpayment:
                     optional_values['quantity'] = -1.0
-                    optional_values['extra_tax_data'] = self.env['account.tax']\
-                        ._reverse_quantity_base_line_extra_tax_data(line.extra_tax_data)
-
+                    optional_values['extra_tax_data'] = self.env['account.tax']._reverse_quantity_base_line_extra_tax_data(line.extra_tax_data)
                 for vals in line._prepare_invoice_lines_vals_list(**optional_values):
                     invoice_line_vals.append(Command.create(vals))
-
                 invoice_item_sequence += 1
-
             invoice_vals['invoice_line_ids'] += invoice_line_vals
             invoice_vals_list.append(invoice_vals)
-
         if not invoice_vals_list and self.env.context.get('raise_if_nothing_to_invoice', True):
             raise UserError(self._nothing_to_invoice_error_message())
-
-        # 2) Manage 'grouped' parameter: group by (partner_id, partner_shipping_id, currency_id).
         if not grouped:
             new_invoice_vals_list = []
             invoice_grouping_keys = self._get_invoice_grouping_keys()
-            invoice_vals_list = sorted(
-                invoice_vals_list,
-                key=lambda x: [
-                    x.get(grouping_key) for grouping_key in invoice_grouping_keys
-                ]
-            )
+            invoice_vals_list = sorted(invoice_vals_list, key=lambda x: [x.get(grouping_key) for grouping_key in invoice_grouping_keys])
             for _grouping_keys, invoices in groupby(invoice_vals_list, key=lambda x: [x.get(grouping_key) for grouping_key in invoice_grouping_keys]):
                 origins = set()
                 payment_refs = set()
@@ -1609,34 +975,9 @@ class SaleOrder(models.Model):
                     origins.add(invoice_vals['invoice_origin'])
                     payment_refs.add(invoice_vals['payment_reference'])
                     refs.add(invoice_vals['ref'])
-                ref_invoice_vals.update({
-                    'ref': ', '.join(refs)[:2000],
-                    'invoice_origin': ', '.join(origins),
-                    'payment_reference': len(payment_refs) == 1 and payment_refs.pop() or False,
-                })
+                ref_invoice_vals.update({'ref': ', '.join(refs)[:2000], 'invoice_origin': ', '.join(origins), 'payment_reference': len(payment_refs) == 1 and payment_refs.pop() or False})
                 new_invoice_vals_list.append(ref_invoice_vals)
             invoice_vals_list = new_invoice_vals_list
-
-        # 3) Create invoices.
-
-        # As part of the invoice creation, we make sure the sequence of multiple SO do not interfere
-        # in a single invoice. Example:
-        # SO 1:
-        # - Section A (sequence: 10)
-        # - Product A (sequence: 11)
-        # SO 2:
-        # - Section B (sequence: 10)
-        # - Product B (sequence: 11)
-        #
-        # If SO 1 & 2 are grouped in the same invoice, the result will be:
-        # - Section A (sequence: 10)
-        # - Section B (sequence: 10)
-        # - Product A (sequence: 11)
-        # - Product B (sequence: 11)
-        #
-        # Resequencing should be safe, however we resequence only if there are less invoices than
-        # orders, meaning a grouping might have been done. This could also mean that only a part
-        # of the selected SO are invoiceable, but resequencing in this case shouldn't be an issue.
         if len(invoice_vals_list) < len(self):
             SaleOrderLine = self.env['sale.order.line']
             for invoice in invoice_vals_list:
@@ -1644,40 +985,22 @@ class SaleOrder(models.Model):
                 for line in invoice['invoice_line_ids']:
                     line[2]['sequence'] = SaleOrderLine._get_invoice_line_sequence(new=sequence, old=line[2]['sequence'])
                     sequence += 1
-
         moves = self._create_account_invoices(invoice_vals_list, final)
-
-        # 4) Some moves might actually be refunds: convert them if the total amount is negative
-        # We do this after the moves have been created since we need taxes, etc. to know if the total
-        # is actually negative or not
         if final and (moves_to_switch := moves.sudo().filtered(lambda m: m.amount_total < 0)):
             with self.env.protecting([moves._fields['team_id']], moves_to_switch):
                 moves_to_switch.action_switch_move_type()
                 self.invoice_ids._set_reversed_entry(moves_to_switch)
-
         for move in moves:
-            move.message_post_with_source(
-                'mail.message_origin_link',
-                render_values={'self': move, 'origin': move.line_ids.sale_line_ids.order_id},
-                subtype_xmlid='mail.mt_note',
-            )
+            move.message_post_with_source('mail.message_origin_link', render_values={'self': move, 'origin': move.line_ids.sale_line_ids.order_id}, subtype_xmlid='mail.mt_note')
         return moves
 
-    # MAIL #
-
     def _discard_tracking(self):
         self.ensure_one()
-        return (
-            self.state == 'draft'
-            and request and request.env.context.get('catalog_skip_tracking')
-        )
+        return self.state == 'draft' and request and request.env.context.get('catalog_skip_tracking')
 
     def _track_finalize(self):
         """ Override of `mail` to prevent logging changes when the SO is in a draft state. """
-        if (len(self) == 1
-            # The method _track_finalize is sometimes called too early or too late and it
-            # might cause a desynchronization with the cache, thus this condition is needed.
-            and self.env.cache.contains(self, self._fields['state']) and self._discard_tracking()):
+        if len(self) == 1 and self.env.cache.contains(self, self._fields['state']) and self._discard_tracking():
             self.env.cr.precommit.data.pop(f'mail.tracking.{self._name}', {})
             self.env.flush_all()
             return
@@ -1690,25 +1013,17 @@ class SaleOrder(models.Model):
         return super().message_post(**kwargs)
 
     def _notify_get_recipients_groups(self, message, model_description, msg_vals=False):
-        # Give access button to users and portal customer as portal is integrated
-        # in sale. Customer and portal group have probably no right to see
-        # the document so they don't have the access button.
-        groups = super()._notify_get_recipients_groups(
-            message, model_description, msg_vals=msg_vals
-        )
+        groups = super()._notify_get_recipients_groups(message, model_description, msg_vals=msg_vals)
         if not self:
             return groups
-
         self.ensure_one()
         if self.env.context.get('proforma'):
             for group in [g for g in groups if g[0] in ('portal_customer', 'portal', 'follower', 'customer')]:
                 group[2]['has_button_access'] = False
             return groups
         local_msg_vals = dict(msg_vals or {})
-
-        # portal customers have full access (existence not granted, depending on partner_id)
         try:
-            customer_portal_group = next(group for group in groups if group[0] == 'portal_customer')
+            customer_portal_group = next((group for group in groups if group[0] == 'portal_customer'))
         except StopIteration:
             pass
         else:
@@ -1716,33 +1031,22 @@ class SaleOrder(models.Model):
             is_tx_pending = self.get_portal_last_transaction().state == 'pending'
             if self._has_to_be_signed():
                 if self._has_to_be_paid():
-                    access_opt['title'] = _("View Quotation") if is_tx_pending else _("Sign & Pay Quotation")
+                    access_opt['title'] = _('View Quotation') if is_tx_pending else _('Sign & Pay Quotation')
                 else:
-                    access_opt['title'] = _("Accept & Sign Quotation")
-            elif self._has_to_be_paid() and not is_tx_pending:
-                access_opt['title'] = _("Accept & Pay Quotation")
+                    access_opt['title'] = _('Accept & Sign Quotation')
+            elif self._has_to_be_paid() and (not is_tx_pending):
+                access_opt['title'] = _('Accept & Pay Quotation')
             elif self.state in ('draft', 'sent'):
-                access_opt['title'] = _("View Quotation")
-
+                access_opt['title'] = _('View Quotation')
         return groups
 
-    def _notify_by_email_prepare_rendering_context(self, message, msg_vals=False, model_description=False,
-                                                   force_email_company=False, force_email_lang=False,
-                                                   force_record_name=False):
-        render_context = super()._notify_by_email_prepare_rendering_context(
-            message, msg_vals=msg_vals, model_description=model_description,
-            force_email_company=force_email_company, force_email_lang=force_email_lang,
-            force_record_name=force_record_name,
-        )
+    def _notify_by_email_prepare_rendering_context(self, message, msg_vals=False, model_description=False, force_email_company=False, force_email_lang=False, force_record_name=False):
+        render_context = super()._notify_by_email_prepare_rendering_context(message, msg_vals=msg_vals, model_description=model_description, force_email_company=force_email_company, force_email_lang=force_email_lang, force_record_name=force_record_name)
         lang_code = render_context.get('lang')
         record = render_context['record']
-        subtitles = [f"{record.name} - {record.partner_id.name}" if record.partner_id.name else record.name]
+        subtitles = [f'{record.name} - {record.partner_id.name}' if record.partner_id.name else record.name]
         if self.amount_total:
-            # Do not show the price in subtitles if zero (e.g. e-commerce orders are created empty)
-            subtitles.append(
-                format_amount(self.env, self.amount_total, self.currency_id, lang_code=lang_code),
-            )
-
+            subtitles.append(format_amount(self.env, self.amount_total, self.currency_id, lang_code=lang_code))
         render_context['subtitles'] = subtitles
         return render_context
 
@@ -1759,8 +1063,6 @@ class SaleOrder(models.Model):
             return self.env.ref('sale.mt_order_sent')
         return super()._track_subtype(init_values)
 
-    # PAYMENT #
-
     def _force_lines_to_invoice_policy_order(self):
         """Force the qty_to_invoice to be computed as if the invoice_policy
         was set to "Ordered quantities", independently of the product configuration.
@@ -1770,22 +1072,17 @@ class SaleOrder(models.Model):
         """
         for line in self.order_line:
             if line.state == 'sale':
-                # No need to set 0 as it is already the standard logic in the compute method.
                 line.qty_to_invoice = line.product_uom_qty - line.qty_invoiced
 
     def payment_action_capture(self):
         """ Capture all transactions linked to this sale order. """
         self.ensure_one()
         payment_utils.check_rights_on_recordset(self)
-
-        # In sudo mode to bypass the checks on the rights on the transactions.
         return self.sudo().transaction_ids.action_capture()
 
     def payment_action_void(self):
         """ Void all transactions linked to this sale order. """
         payment_utils.check_rights_on_recordset(self)
-
-        # In sudo mode to bypass the checks on the rights on the transactions.
         self.sudo().authorized_transaction_ids.action_void()
 
     def get_portal_last_transaction(self):
@@ -1793,50 +1090,24 @@ class SaleOrder(models.Model):
         return self.sudo().transaction_ids._get_last()
 
     def _get_order_lines_to_report(self):
-        down_payment_lines = self.order_line.filtered(lambda line:
-            line.is_downpayment
-            and not line.display_type
-            and not line._get_downpayment_state()
-        )
+        down_payment_lines = self.order_line.filtered(lambda line: line.is_downpayment and (not line.display_type) and (not line._get_downpayment_state()))
 
         def show_line(line):
             if line.is_downpayment:
-                return (
-                    # Only show the down payment section if down payments were posted
-                    (line.display_type and down_payment_lines)
-                    # Only show posted down payments
-                    or line in down_payment_lines
-                )
-            return (
-                line.display_type == 'line_section'
-                or not (
-                    line.parent_id.collapse_composition
-                    or line.parent_id.parent_id.collapse_composition
-                )
-            )
-
+                return line.display_type and down_payment_lines or line in down_payment_lines
+            return line.display_type == 'line_section' or not (line.parent_id.collapse_composition or line.parent_id.parent_id.collapse_composition)
         return self.order_line.filtered(show_line)
 
     def _get_default_payment_link_values(self):
         """ Override of `payment` to compute the default values of the payment link wizard. """
         self.ensure_one()
-
         prepayment_amount = self._get_prepayment_required_amount()
         remaining_balance = self.amount_total - self.amount_paid
         if self.state in ('draft', 'sent') and self.require_payment:
-            suggested_amount = prepayment_amount  # Suggest the amount needed to confirm the quote.
-        else:  # The order is confirmed or doesn't require payment.
+            suggested_amount = prepayment_amount
+        else:
             suggested_amount = remaining_balance
-        return {
-            'currency_id': self.currency_id.id,
-            'partner_id': self.partner_invoice_id.id,
-            'amount': suggested_amount,
-            'amount_max': remaining_balance,
-            'amount_paid': self.amount_paid,
-            'prepayment_amount': prepayment_amount,
-        }
-
-    # EDI #
+        return {'currency_id': self.currency_id.id, 'partner_id': self.partner_invoice_id.id, 'amount': suggested_amount, 'amount_max': remaining_balance, 'amount_paid': self.amount_paid, 'prepayment_amount': prepayment_amount}
 
     def _get_edi_builders(self):
         return []
@@ -1850,13 +1121,9 @@ class SaleOrder(models.Model):
         """
         attachments = self.env['ir.attachment'].browse(attachment_ids)
         if not attachments:
-            raise UserError(_("No attachment was provided"))
-
+            raise UserError(_('No attachment was provided'))
         orders = self.with_context(default_partner_id=self.env.user.partner_id.id)._create_records_from_attachments(attachments)
-
-        return orders._get_records_action(name=_("Generated Orders"))
-
-    # PORTAL #
+        return orders._get_records_action(name=_('Generated Orders'))
 
     def _has_to_be_signed(self):
         """A sale order has to be signed when:
@@ -1871,12 +1138,7 @@ class SaleOrder(models.Model):
         :rtype: bool
         """
         self.ensure_one()
-        return (
-            self.state in ['draft', 'sent']
-            and not self.is_expired
-            and self.require_signature
-            and not self.signature
-        )
+        return self.state in ['draft', 'sent'] and (not self.is_expired) and self.require_signature and (not self.signature)
 
     def _has_to_be_paid(self):
         """A sale order has to be paid when:
@@ -1893,13 +1155,7 @@ class SaleOrder(models.Model):
         :rtype: bool
         """
         self.ensure_one()
-        return (
-            self.state in ['draft', 'sent']
-            and not self.is_expired
-            and self.require_payment
-            and self.amount_total > 0
-            and not self._is_confirmation_amount_reached()
-        )
+        return self.state in ['draft', 'sent'] and (not self.is_expired) and self.require_payment and (self.amount_total > 0) and (not self._is_confirmation_amount_reached())
 
     def _get_portal_return_action(self):
         """ Return the action used to display orders when returning from customer portal. """
@@ -1919,42 +1175,27 @@ class SaleOrder(models.Model):
         self.ensure_one()
         return f'{self.type_name} {self.name}'
 
-    #=== CORE METHODS OVERRIDES ===#
-
     @api.model
     def get_empty_list_help(self, help_message):
-        self = self.with_context(
-            empty_list_help_document_name=_("sale order"),
-        )
+        self = self.with_context(empty_list_help_document_name=_('sale order'))
         return super().get_empty_list_help(help_message)
 
     def _compute_field_value(self, field):
         if field.name != 'invoice_status' or self.env.context.get('mail_activity_automation_skip'):
             return super()._compute_field_value(field)
-
-        filtered_self = self.filtered(
-            lambda so: so.ids
-                and (so.user_id or so.partner_id.user_id)
-                and so._origin.invoice_status != 'upselling')
+        filtered_self = self.filtered(lambda so: so.ids and (so.user_id or so.partner_id.user_id) and (so._origin.invoice_status != 'upselling'))
         super()._compute_field_value(field)
-
         upselling_orders = filtered_self.filtered(lambda so: so.invoice_status == 'upselling')
         upselling_orders._create_upsell_activity()
 
-    #=== BUSINESS METHODS ===#
-
     def _create_upsell_activity(self):
         if not self:
             return
-
         self.activity_unlink(['mail.mail_activity_data_todo'])
         for order in self:
             order_ref = order._get_html_link()
             customer_ref = order.partner_id._get_html_link()
-            order.activity_schedule(
-                'mail.mail_activity_data_todo',
-                user_id=order.user_id.id or order.partner_id.user_id.id,
-                note=_("Upsell %(order)s for customer %(customer)s", order=order_ref, customer=customer_ref))
+            order.activity_schedule('mail.mail_activity_data_todo', user_id=order.user_id.id or order.partner_id.user_id.id, note=_('Upsell %(order)s for customer %(customer)s', order=order_ref, customer=customer_ref))
 
     def _prepare_analytic_account_data(self, prefix=None):
         """ Prepare SO analytic account creation values.
@@ -1965,15 +1206,9 @@ class SaleOrder(models.Model):
         self.ensure_one()
         name = self.name
         if prefix:
-            name = prefix + ": " + self.name
+            name = prefix + ': ' + self.name
         project_plan, _other_plans = self.env['account.analytic.plan']._get_all_plans()
-        return {
-            'name': name,
-            'code': self.client_order_ref,
-            'company_id': self.company_id.id,
-            'plan_id': project_plan.id,
-            'partner_id': self.partner_id.id,
-        }
+        return {'name': name, 'code': self.client_order_ref, 'company_id': self.company_id.id, 'plan_id': project_plan.id, 'partner_id': self.partner_id.id}
 
     def _prepare_down_payment_section_line(self, **optional_values):
         """ Prepare the values to create a new down payment section.
@@ -1984,17 +1219,7 @@ class SaleOrder(models.Model):
         """
         self.ensure_one()
         context = {'lang': self.partner_id.lang}
-        down_payments_section_line = {
-            'display_type': 'line_section',
-            'name': _("Down Payments"),
-            'product_id': False,
-            'product_uom_id': False,
-            'quantity': 0,
-            'discount': 0,
-            'price_unit': 0,
-            'account_id': False,
-            **optional_values
-        }
+        down_payments_section_line = {'display_type': 'line_section', 'name': _('Down Payments'), 'product_id': False, 'product_uom_id': False, 'quantity': 0, 'discount': 0, 'price_unit': 0, 'account_id': False, **optional_values}
         del context
         return down_payments_section_line
 
@@ -2007,15 +1232,7 @@ class SaleOrder(models.Model):
         """
         self.ensure_one()
         sequence = max(self.order_line.mapped('sequence') or [10]) + 1
-        return self.env['sale.order.line'] \
-            .with_context(sale_no_log_for_new_lines=True) \
-            .create([
-                {
-                    **self._prepare_down_payment_line_values_from_base_line(base_line),
-                    'sequence': sequence + index,
-                }
-                for index, base_line in enumerate(down_payment_base_lines)
-            ])
+        return self.env['sale.order.line'].with_context(sale_no_log_for_new_lines=True).create([{**self._prepare_down_payment_line_values_from_base_line(base_line), 'sequence': sequence + index} for index, base_line in enumerate(down_payment_base_lines)])
 
     def _create_down_payment_section_line_if_needed(self):
         """ Add the down section line if not already there on the current SO.
@@ -2023,18 +1240,10 @@ class SaleOrder(models.Model):
         :return The newly created SO line or None if the section was already there.
         """
         self.ensure_one()
-        # If a down payment is already there, then the section is not needed and
-        # has already been created.
-        if any(line.display_type and line.is_downpayment for line in self.order_line):
+        if any((line.display_type and line.is_downpayment for line in self.order_line)):
             return
-
         sequence = max(self.order_line.mapped('sequence') or [10]) + 1
-        return self.env['sale.order.line'] \
-            .with_context(sale_no_log_for_new_lines=True) \
-            .create({
-                **self._prepare_down_payment_line_section_values(),
-                'sequence': sequence,
-            })
+        return self.env['sale.order.line'].with_context(sale_no_log_for_new_lines=True).create({**self._prepare_down_payment_line_section_values(), 'sequence': sequence})
 
     def _prepare_down_payment_line_section_values(self):
         """ Prepare the values to create a section line for the down payment on the current SO.
@@ -2042,11 +1251,7 @@ class SaleOrder(models.Model):
         :return: A dictionary to create a new SO section line.
         """
         self.ensure_one()
-        return {
-            'order_id': self.id,
-            'display_type': 'line_section',
-            'is_downpayment': True,
-        }
+        return {'order_id': self.id, 'display_type': 'line_section', 'is_downpayment': True}
 
     def _prepare_down_payment_line_values_from_base_line(self, base_line):
         """ Convert the base line passed as parameter representing a down payment into a
@@ -2057,15 +1262,7 @@ class SaleOrder(models.Model):
         """
         self.ensure_one()
         extra_tax_data = self.env['account.tax']._export_base_line_extra_tax_data(base_line)
-        return {
-            'order_id': self.id,
-            'is_downpayment': True,
-            'product_uom_qty': 0.0,
-            'price_unit': base_line['price_unit'],
-            'tax_ids': [Command.set(base_line['tax_ids'].ids)],
-            'analytic_distribution': base_line['analytic_distribution'],
-            'extra_tax_data': extra_tax_data,
-        }
+        return {'order_id': self.id, 'is_downpayment': True, 'product_uom_qty': 0.0, 'price_unit': base_line['price_unit'], 'tax_ids': [Command.set(base_line['tax_ids'].ids)], 'analytic_distribution': base_line['analytic_distribution'], 'extra_tax_data': extra_tax_data}
 
     def _get_prepayment_required_amount(self):
         """ Return the minimum amount needed to automatically confirm the quotation.
@@ -2076,7 +1273,6 @@ class SaleOrder(models.Model):
         :rtype: float
         """
         self.ensure_one()
-
         if not self.require_payment:
             return 0
         else:
@@ -2091,9 +1287,7 @@ class SaleOrder(models.Model):
         :rtype: bool
         """
         self.ensure_one()
-        amount_comparison = self.currency_id.compare_amounts(
-            self._get_prepayment_required_amount(), self.amount_paid,
-        )
+        amount_comparison = self.currency_id.compare_amounts(self._get_prepayment_required_amount(), self.amount_paid)
         return amount_comparison <= 0
 
     def _generate_downpayment_invoices(self):
@@ -2103,27 +1297,13 @@ class SaleOrder(models.Model):
         :rtype: recordset of `account.move`
         """
         generated_invoices = self.env['account.move']
-
         for order in self:
-            downpayment_wizard = order.env['sale.advance.payment.inv'].create({
-                'sale_order_ids': order,
-                'advance_payment_method': 'fixed',
-                'fixed_amount': order.amount_paid,
-            })
+            downpayment_wizard = order.env['sale.advance.payment.inv'].create({'sale_order_ids': order, 'advance_payment_method': 'fixed', 'fixed_amount': order.amount_paid})
             generated_invoices |= downpayment_wizard._create_invoices(order)
-
         return generated_invoices
 
-    # === CATALOG === #
-
     def _get_product_catalog_order_data(self, products, **kwargs):
-        pricelist = self.pricelist_id._get_products_price(
-            quantity=1.0,
-            products=products,
-            currency=self.currency_id,
-            date=self.date_order,
-            **kwargs,
-        )
+        pricelist = self.pricelist_id._get_products_price(quantity=1.0, products=products, currency=self.currency_id, date=self.date_order, **kwargs)
         res = super()._get_product_catalog_order_data(products, **kwargs)
         for product in products:
             res[product.id]['price'] = pricelist.get(product.id)
@@ -2134,17 +1314,9 @@ class SaleOrder(models.Model):
     def _get_product_catalog_record_lines(self, product_ids, *, section_id=None, **kwargs):
         grouped_lines = defaultdict(lambda: self.env['sale.order.line'])
         if section_id is None:
-            section_id = (
-                self.order_line[:1].id
-                if self.order_line[:1].display_type == 'line_section'
-                else False
-            )
+            section_id = self.order_line[:1].id if self.order_line[:1].display_type == 'line_section' else False
         for line in self.order_line:
-            if (
-                line.display_type
-                or line.product_id.id not in product_ids
-                or line.get_parent_section_line().id != section_id
-            ):
+            if line.display_type or line.product_id.id not in product_ids or line.get_parent_section_line().id != section_id:
                 continue
             grouped_lines[line.product_id] |= line
         return grouped_lines
@@ -2152,9 +1324,7 @@ class SaleOrder(models.Model):
     def _get_parent_field_on_child_model(self):
         return 'order_id'
 
-    def _update_order_line_info(
-        self, product_id, quantity, *, section_id=False, child_field='order_line', **kwargs
-    ):
+    def _update_order_line_info(self, product_id, quantity, *, section_id=False, child_field='order_line', **kwargs):
         """ Update sale order line information for a given product or create a
         new one if none exists yet.
         :param int product_id: The product, as a `product.product` id.
@@ -2165,53 +1335,27 @@ class SaleOrder(models.Model):
         :rtype: float
         """
         request.update_context(catalog_skip_tracking=True)
-        sol = self.order_line.filtered(
-            lambda l: l.product_id.id == product_id
-            and l.get_parent_section_line().id == section_id,
-        )
+        sol = self.order_line.filtered(lambda l: l.product_id.id == product_id and l.get_parent_section_line().id == section_id)
         if sol:
             if quantity != 0:
                 sol.product_uom_qty = quantity
             elif self.state in ['draft', 'sent']:
-                price_unit = self.pricelist_id._get_product_price(
-                    product=sol.product_id,
-                    quantity=1.0,
-                    currency=self.currency_id,
-                    date=self.date_order,
-                    **kwargs,
-                )
+                price_unit = self.pricelist_id._get_product_price(product=sol.product_id, quantity=1.0, currency=self.currency_id, date=self.date_order, **kwargs)
                 sol.unlink()
                 return price_unit
             else:
                 sol.product_uom_qty = 0
         elif quantity > 0:
-            sol = self.env['sale.order.line'].create({
-                'order_id': self.id,
-                'product_id': product_id,
-                'product_uom_qty': quantity,
-                'sequence': self._get_new_line_sequence(child_field, section_id),
-            })
-        return sol.price_unit * (1-(sol.discount or 0.0)/100.0)
-
-    # === Product Documents === #
+            sol = self.env['sale.order.line'].create({'order_id': self.id, 'product_id': product_id, 'product_uom_qty': quantity, 'sequence': self._get_new_line_sequence(child_field, section_id)})
+        return sol.price_unit * (1 - (sol.discount or 0.0) / 100.0)
 
     def _get_product_documents(self):
         self.ensure_one()
-
-        documents = (
-            self.order_line.product_id.product_document_ids
-            | self.order_line.product_template_id.product_document_ids
-        )
+        documents = self.order_line.product_id.product_document_ids | self.order_line.product_template_id.product_document_ids
         return self._filter_product_documents(documents).sorted()
 
     def _filter_product_documents(self, documents):
-        return documents.filtered(
-            lambda document:
-                document.attached_on_sale == 'quotation'
-                or (self.state == 'sale' and document.attached_on_sale == 'sale_order')
-        )
-
-    #=== TOOLING ===#
+        return documents.filtered(lambda document: document.attached_on_sale == 'quotation' or (self.state == 'sale' and document.attached_on_sale == 'sale_order'))
 
     def _is_readonly(self):
         """ Return Whether the sale order is read-only or not based on the state or the lock status.
@@ -2239,20 +1383,14 @@ class SaleOrder(models.Model):
 
     def _get_lang(self):
         self.ensure_one()
-
-        if self.partner_id.lang and not self.partner_id.is_public:
+        if self.partner_id.lang and (not self.partner_id.is_public):
             return self.partner_id.lang
-
         return self.env.lang
 
     @api.model
     def get_import_templates(self):
-        return [{
-            'label': _('Import Template for Quotations'),
-            'template': '/sale/static/xls/quotations_import_template.xlsx',
-        }]
+        return [{'label': _('Import Template for Quotations'), 'template': '/sale/static/xls/quotations_import_template.xlsx'}]
 
-    # For `sale_management`, to control optional products on portal
     def _can_be_edited_on_portal(self):
         self.ensure_one()
-        return self.state in ('draft', 'sent')
+        return self.state in ('draft', 'sent')
\ No newline at end of file

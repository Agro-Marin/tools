diff --git a/addons/sale/models/sale_order.py b/addons/sale/models/sale_order.py
index b65bccd362f8..edd9325693ce 100644
--- a/addons/sale/models/sale_order.py
+++ b/addons/sale/models/sale_order.py
@@ -1,11 +1,8 @@
-# Part of Odoo. See LICENSE file for full copyright and licensing details.
-
 import json
 import logging
 from collections import defaultdict
 from datetime import timedelta
 from itertools import groupby
-
 from odoo import SUPERUSER_ID, _, api, fields, models
 from odoo.exceptions import AccessError, UserError, ValidationError
 from odoo.fields import Command, Domain
@@ -13,321 +10,89 @@ from odoo.http import request
 from odoo.tools import SQL, OrderedSet, float_is_zero, format_amount, is_html_empty
 from odoo.tools.mail import html_keep_url
 from odoo.tools.misc import str2bool
-
 from odoo.addons.payment import utils as payment_utils
-
-INVOICE_STATUS = [
-    ('upselling', 'Upselling Opportunity'),
-    ('invoiced', 'Fully Invoiced'),
-    ('to invoice', 'To Invoice'),
-    ('no', 'Nothing to Invoice')
-]
-
-SALE_ORDER_STATE = [
-    ('draft', "Quotation"),
-    ('sent', "Quotation Sent"),
-    ('sale', "Sales Order"),
-    ('cancel', "Cancelled"),
-]
-
+INVOICE_STATUS = [('upselling', 'Upselling Opportunity'), ('invoiced', 'Fully Invoiced'), ('to invoice', 'To Invoice'), ('no', 'Nothing to Invoice')]
+SALE_ORDER_STATE = [('draft', 'Quotation'), ('sent', 'Quotation Sent'), ('sale', 'Sales Order'), ('cancel', 'Cancelled')]
 
 class SaleOrder(models.Model):
     _name = 'sale.order'
     _inherit = ['portal.mixin', 'product.catalog.mixin', 'mail.thread', 'mail.activity.mixin', 'utm.mixin', 'account.document.import.mixin']
-    _description = "Sales Order"
+    _description = 'Sales Order'
     _order = 'date_order desc, id desc'
     _check_company_auto = True
-
-    _date_order_conditional_required = models.Constraint(
-        "CHECK((state = 'sale' AND date_order IS NOT NULL) OR state != 'sale')",
-        'A confirmed sales order requires a confirmation date.',
-    )
+    _date_order_conditional_required = models.Constraint("CHECK((state = 'sale' AND date_order IS NOT NULL) OR state != 'sale')", 'A confirmed sales order requires a confirmation date.')
 
     @property
     def _rec_names_search(self):
         if self.env.context.get('sale_show_partner_name'):
             return ['name', 'partner_id.name']
         return ['name']
-
-    #=== FIELDS ===#
-
-    name = fields.Char(
-        string="Order Reference",
-        required=True, copy=False, readonly=False,
-        index='trigram',
-        default=lambda self: _('New'))
-
-    company_id = fields.Many2one(
-        comodel_name='res.company',
-        required=True, index=True,
-        default=lambda self: self.env.company)
-    partner_id = fields.Many2one(
-        comodel_name='res.partner',
-        string="Customer",
-        required=True, change_default=True, index=True,
-        tracking=1,
-        check_company=True)
-    state = fields.Selection(
-        selection=SALE_ORDER_STATE,
-        string="Status",
-        readonly=True, copy=False, index=True,
-        tracking=3,
-        default='draft')
-    locked = fields.Boolean(
-        help="Locked orders cannot be modified.",
-        default=False,
-        copy=False,
-        tracking=True)
-    has_archived_products = fields.Boolean(compute="_compute_has_archived_products")
-
-    client_order_ref = fields.Char(string="Customer Reference", copy=False)
-    create_date = fields.Datetime(  # Override of default create_date field from ORM
-        string="Creation Date", index=True, readonly=True)
-    commitment_date = fields.Datetime(
-        string="Delivery Date", copy=False,
-        help="This is the delivery date promised to the customer. "
-             "If set, the delivery order will be scheduled based on "
-             "this date rather than product lead times.")
-    date_order = fields.Datetime(
-        string="Order Date",
-        required=True, copy=False,
-        help="Creation date of draft/sent orders,\nConfirmation date of confirmed orders.",
-        default=fields.Datetime.now)
-    origin = fields.Char(
-        string="Source Document",
-        help="Reference of the document that generated this sales order request")
-    reference = fields.Char(
-        string="Payment Ref.",
-        help="The payment communication of this sale order.",
-        copy=False)
-    pending_email_template_id = fields.Many2one(
-        string="Pending Email Template",
-        comodel_name='mail.template',
-        ondelete='set null',
-        readonly=True,
-    )  # The template of the pending email that must be sent asynchronously.
-
-    require_signature = fields.Boolean(
-        string="Online signature",
-        compute='_compute_require_signature',
-        store=True, readonly=False, precompute=True,
-        help="Request a online signature from the customer to confirm the order.")
-    require_payment = fields.Boolean(
-        string="Online payment",
-        compute='_compute_require_payment',
-        store=True, readonly=False, precompute=True,
-        help="Request a online payment from the customer to confirm the order.")
-    prepayment_percent = fields.Float(
-        string="Prepayment percentage",
-        compute='_compute_prepayment_percent',
-        store=True, readonly=False, precompute=True,
-        help="The percentage of the amount needed that must be paid by the customer to confirm the order.")
-
-    signature = fields.Image(
-        string="Signature",
-        copy=False, attachment=True, max_width=1024, max_height=1024)
-    signed_by = fields.Char(
-        string="Signed By", copy=False)
-    signed_on = fields.Datetime(
-        string="Signed On", copy=False)
-
-    validity_date = fields.Date(
-        string="Expiration",
-        help="Validity of the order, after that you will not able to sign & pay the quotation.",
-        compute='_compute_validity_date',
-        store=True, readonly=False, copy=False, precompute=True)
-    journal_id = fields.Many2one(
-        'account.journal', string="Invoicing Journal",
-        compute="_compute_journal_id", store=True, readonly=False, precompute=True,
-        domain=[('type', '=', 'sale')], check_company=True,
-        help="If set, the SO will invoice in this journal; "
-             "otherwise the sales journal with the lowest sequence is used.")
-
-    # Partner-based computes
-    note = fields.Html(
-        string="Terms and conditions",
-        compute='_compute_note',
-        store=True, readonly=False, precompute=True)
-
-    partner_invoice_id = fields.Many2one(
-        comodel_name='res.partner',
-        string="Invoice Address",
-        compute='_compute_partner_invoice_id',
-        store=True, readonly=False, required=True, precompute=True,
-        check_company=True,
-        index='btree_not_null')
-    partner_shipping_id = fields.Many2one(
-        comodel_name='res.partner',
-        string="Delivery Address",
-        compute='_compute_partner_shipping_id',
-        store=True, readonly=False, required=True, precompute=True,
-        check_company=True,
-        index='btree_not_null')
-
-    fiscal_position_id = fields.Many2one(
-        comodel_name='account.fiscal.position',
-        string="Fiscal Position",
-        compute='_compute_fiscal_position_id',
-        store=True, readonly=False, precompute=True, check_company=True,
-        help="Fiscal positions are used to adapt taxes and accounts for particular customers or sales orders/invoices."
-            "The default value comes from the customer.",
-    )
-    payment_term_id = fields.Many2one(
-        comodel_name='account.payment.term',
-        string="Payment Terms",
-        compute='_compute_payment_term_id',
-        store=True, readonly=False, precompute=True, check_company=True,  # Unrequired company
-        domain="['|', ('company_id', '=', False), ('company_id', '=', company_id)]")
-    preferred_payment_method_line_id = fields.Many2one(
-        comodel_name="account.payment.method.line", string="Payment Method",
-        compute="_compute_preferred_payment_method_line_id",
-        store=True, precompute=True, readonly=False, check_company=True,
-        domain="[('payment_type', '=', 'inbound'), ('company_id', '=', company_id)]")
-    pricelist_id = fields.Many2one(
-        comodel_name='product.pricelist',
-        string="Pricelist",
-        compute='_compute_pricelist_id',
-        store=True, readonly=False, precompute=True, check_company=True,  # Unrequired company
-        tracking=1,
-        domain="['|', ('company_id', '=', False), ('company_id', '=', company_id)]",
-        help="If you change the pricelist, only newly added lines will be affected.")
-    currency_id = fields.Many2one(
-        comodel_name='res.currency',
-        compute='_compute_currency_id',
-        store=True,
-        precompute=True,
-        ondelete='restrict'
-    )
-    currency_rate = fields.Float(
-        string="Currency Rate",
-        compute='_compute_currency_rate',
-        digits=0,
-        store=True, precompute=True)
-    user_id = fields.Many2one(
-        comodel_name='res.users',
-        string="Salesperson",
-        compute='_compute_user_id',
-        store=True, readonly=False, precompute=True, index=True,
-        tracking=2,
-        domain=lambda self: "[('all_group_ids', 'in', {}), ('share', '=', False), ('company_ids', '=', company_id)]".format(
-            self.env.ref("sales_team.group_sale_salesman").ids
-        ))
-    team_id = fields.Many2one(
-        comodel_name='crm.team',
-        string="Sales Team",
-        compute='_compute_team_id',
-        store=True, readonly=False, precompute=True, ondelete="set null",
-        change_default=True, check_company=True,  # Unrequired company
-        tracking=True,
-        domain="['|', ('company_id', '=', False), ('company_id', '=', company_id)]")
-
-    # Lines and line based computes
-    order_line = fields.One2many(
-        comodel_name='sale.order.line',
-        inverse_name='order_id',
-        string="Order Lines",
-        copy=True, bypass_search_access=True)
-
-    amount_untaxed = fields.Monetary(string="Untaxed Amount", store=True, compute='_compute_amounts', tracking=5)
-    amount_tax = fields.Monetary(string="Taxes", store=True, compute='_compute_amounts')
-    amount_total = fields.Monetary(string="Total", store=True, compute='_compute_amounts', tracking=4)
-    amount_to_invoice = fields.Monetary(string="Un-invoiced Balance", compute='_compute_amount_to_invoice')
-    amount_invoiced = fields.Monetary(string="Already invoiced", compute='_compute_amount_invoiced')
-
-    invoice_count = fields.Integer(string="Invoice Count", compute='_get_invoiced')
-    invoice_ids = fields.Many2many(
-        comodel_name='account.move',
-        string="Invoices",
-        compute='_get_invoiced',
-        search='_search_invoice_ids',
-        copy=False)
-    invoice_status = fields.Selection(
-        selection=INVOICE_STATUS,
-        string="Invoice Status",
-        compute='_compute_invoice_status',
-        store=True)
-
-    sale_warning_text = fields.Text(
-        "Sale Warning",
-        help="Internal warning for the partner or the products as set by the user.",
-        compute='_compute_sale_warning_text')
-
-    # Payment fields
-    transaction_ids = fields.Many2many(
-        comodel_name='payment.transaction',
-        relation='sale_order_transaction_rel', column1='sale_order_id', column2='transaction_id',
-        string="Transactions",
-        groups='account.group_account_invoice',
-        copy=False, readonly=True)
-    authorized_transaction_ids = fields.Many2many(
-        comodel_name='payment.transaction',
-        string="Authorized Transactions",
-        compute='_compute_authorized_transaction_ids',
-        copy=False,
-        groups='account.group_account_invoice',
-        compute_sudo=True)
-    has_authorized_transaction_ids = fields.Boolean(
-        string="Has Authorized Transactions",
-        compute='_compute_authorized_transaction_ids',
-        compute_sudo=True)
-    amount_paid = fields.Float(
-        string="Payment Transactions Amount",
-        help="Sum of transactions made in through the online payment form that are in the state"
-             " 'done' or 'authorized' and linked to this order.",
-        compute='_compute_amount_paid',
-        compute_sudo=True,
-    )
-
-    # UTMs - enforcing the fact that we want to 'set null' when relation is unlinked
+    name = fields.Char(string='Order Reference', required=True, copy=False, readonly=False, index='trigram', default=lambda self: _('New'))
+    company_id = fields.Many2one(comodel_name='res.company', required=True, index=True, default=lambda self: self.env.company)
+    partner_id = fields.Many2one(comodel_name='res.partner', string='Customer', required=True, change_default=True, index=True, tracking=1, check_company=True)
+    state = fields.Selection(selection=SALE_ORDER_STATE, string='Status', readonly=True, copy=False, index=True, tracking=3, default='draft')
+    locked = fields.Boolean(help='Locked orders cannot be modified.', default=False, copy=False, tracking=True)
+    has_archived_products = fields.Boolean(compute='_compute_has_archived_products')
+    client_order_ref = fields.Char(string='Customer Reference', copy=False)
+    create_date = fields.Datetime(string='Creation Date', index=True, readonly=True)
+    date_commitment = fields.Datetime(string='Delivery Date', copy=False, help='This is the delivery date promised to the customer. If set, the delivery order will be scheduled based on this date rather than product lead times.')
+    date_order = fields.Datetime(string='Order Date', required=True, copy=False, help='Creation date of draft/sent orders,\nConfirmation date of confirmed orders.', default=fields.Datetime.now)
+    origin = fields.Char(string='Source Document', help='Reference of the document that generated this sales order request')
+    reference = fields.Char(string='Payment Ref.', help='The payment communication of this sale order.', copy=False)
+    pending_email_template_id = fields.Many2one(string='Pending Email Template', comodel_name='mail.template', ondelete='set null', readonly=True)
+    require_signature = fields.Boolean(string='Online signature', compute='_compute_require_signature', store=True, readonly=False, precompute=True, help='Request a online signature from the customer to confirm the order.')
+    require_payment = fields.Boolean(string='Online payment', compute='_compute_require_payment', store=True, readonly=False, precompute=True, help='Request a online payment from the customer to confirm the order.')
+    prepayment_percent = fields.Float(string='Prepayment percentage', compute='_compute_prepayment_percent', store=True, readonly=False, precompute=True, help='The percentage of the amount needed that must be paid by the customer to confirm the order.')
+    signature = fields.Image(string='Signature', copy=False, attachment=True, max_width=1024, max_height=1024)
+    signed_by = fields.Char(string='Signed By', copy=False)
+    signed_on = fields.Datetime(string='Signed On', copy=False)
+    date_validity = fields.Date(string='Expiration', help='Validity of the order, after that you will not able to sign & pay the quotation.', compute='_compute_date_validity', store=True, readonly=False, copy=False, precompute=True)
+    journal_id = fields.Many2one('account.journal', string='Invoicing Journal', compute='_compute_journal_id', store=True, readonly=False, precompute=True, domain=[('type', '=', 'sale')], check_company=True, help='If set, the SO will invoice in this journal; otherwise the sales journal with the lowest sequence is used.')
+    note = fields.Html(string='Terms and conditions', compute='_compute_note', store=True, readonly=False, precompute=True)
+    partner_invoice_id = fields.Many2one(comodel_name='res.partner', string='Invoice Address', compute='_compute_partner_invoice_id', store=True, readonly=False, required=True, precompute=True, check_company=True, index='btree_not_null')
+    partner_shipping_id = fields.Many2one(comodel_name='res.partner', string='Delivery Address', compute='_compute_partner_shipping_id', store=True, readonly=False, required=True, precompute=True, check_company=True, index='btree_not_null')
+    fiscal_position_id = fields.Many2one(comodel_name='account.fiscal.position', string='Fiscal Position', compute='_compute_fiscal_position_id', store=True, readonly=False, precompute=True, check_company=True, help='Fiscal positions are used to adapt taxes and accounts for particular customers or sales orders/invoices.The default value comes from the customer.')
+    payment_term_id = fields.Many2one(comodel_name='account.payment.term', string='Payment Terms', compute='_compute_payment_term_id', store=True, readonly=False, precompute=True, check_company=True, domain="['|', ('company_id', '=', False), ('company_id', '=', company_id)]")
+    preferred_payment_method_line_id = fields.Many2one(comodel_name='account.payment.method.line', string='Payment Method', compute='_compute_preferred_payment_method_line_id', store=True, precompute=True, readonly=False, check_company=True, domain="[('payment_type', '=', 'inbound'), ('company_id', '=', company_id)]")
+    pricelist_id = fields.Many2one(comodel_name='product.pricelist', string='Pricelist', compute='_compute_pricelist_id', store=True, readonly=False, precompute=True, check_company=True, tracking=1, domain="['|', ('company_id', '=', False), ('company_id', '=', company_id)]", help='If you change the pricelist, only newly added lines will be affected.')
+    currency_id = fields.Many2one(comodel_name='res.currency', compute='_compute_currency_id', store=True, precompute=True, ondelete='restrict')
+    currency_rate = fields.Float(string='Currency Rate', compute='_compute_currency_rate', digits=0, store=True, precompute=True)
+    user_id = fields.Many2one(comodel_name='res.users', string='Salesperson', compute='_compute_user_id', store=True, readonly=False, precompute=True, index=True, tracking=2, domain=lambda self: "[('all_group_ids', 'in', {}), ('share', '=', False), ('company_ids', '=', company_id)]".format(self.env.ref('sales_team.group_sale_salesman').ids))
+    team_id = fields.Many2one(comodel_name='crm.team', string='Sales Team', compute='_compute_team_id', store=True, readonly=False, precompute=True, ondelete='set null', change_default=True, check_company=True, tracking=True, domain="['|', ('company_id', '=', False), ('company_id', '=', company_id)]")
+    line_ids = fields.One2many(comodel_name='sale.order.line', inverse_name='order_id', string='Order Lines', copy=True, bypass_search_access=True)
+    amount_untaxed = fields.Monetary(string='Untaxed Amount', store=True, compute='_compute_amounts', tracking=5)
+    amount_tax = fields.Monetary(string='Taxes', store=True, compute='_compute_amounts')
+    amount_total = fields.Monetary(string='Total', store=True, compute='_compute_amounts', tracking=4)
+    amount_to_invoice_taxinc = fields.Monetary(string='Un-invoiced Balance', compute='_compute_amount_to_invoice_taxinc')
+    amount_invoiced_taxinc = fields.Monetary(string='Already invoiced', compute='_compute_amount_invoiced_taxinc')
+    invoice_count = fields.Integer(string='Invoice Count', compute='_get_invoiced')
+    invoice_ids = fields.Many2many(comodel_name='account.move', string='Invoices', compute='_get_invoiced', search='_search_invoice_ids', copy=False)
+    invoice_state = fields.Selection(selection=INVOICE_STATUS, string='Invoice Status', compute='_compute_invoice_state', store=True)
+    sale_warning_text = fields.Text('Sale Warning', help='Internal warning for the partner or the products as set by the user.', compute='_compute_sale_warning_text')
+    transaction_ids = fields.Many2many(comodel_name='payment.transaction', relation='sale_order_transaction_rel', column1='sale_order_id', column2='transaction_id', string='Transactions', groups='account.group_account_invoice', copy=False, readonly=True)
+    authorized_transaction_ids = fields.Many2many(comodel_name='payment.transaction', string='Authorized Transactions', compute='_compute_authorized_transaction_ids', copy=False, groups='account.group_account_invoice', compute_sudo=True)
+    has_authorized_transaction_ids = fields.Boolean(string='Has Authorized Transactions', compute='_compute_authorized_transaction_ids', compute_sudo=True)
+    amount_paid = fields.Float(string='Payment Transactions Amount', help="Sum of transactions made in through the online payment form that are in the state 'done' or 'authorized' and linked to this order.", compute='_compute_amount_paid', compute_sudo=True)
     campaign_id = fields.Many2one(ondelete='set null')
     medium_id = fields.Many2one(ondelete='set null')
     source_id = fields.Many2one(ondelete='set null')
-
-    # Followup ?
-    tag_ids = fields.Many2many(
-        comodel_name='crm.tag',
-        relation='sale_order_tag_rel', column1='order_id', column2='tag_id',
-        groups="sales_team.group_sale_salesman",
-        string="Tags")
-
-    # Remaining non stored computed fields (hide/make fields readonly, ...)
-    amount_undiscounted = fields.Float(
-        string="Amount Before Discount",
-        compute='_compute_amount_undiscounted', digits=0)
-    country_code = fields.Char(related='company_id.account_fiscal_country_id.code', string="Country code")
+    tag_ids = fields.Many2many(comodel_name='crm.tag', relation='sale_order_tag_rel', column1='order_id', column2='tag_id', groups='sales_team.group_sale_salesman', string='Tags')
+    amount_undiscounted = fields.Float(string='Amount Before Discount', compute='_compute_amount_undiscounted', digits=0)
+    country_code = fields.Char(related='company_id.account_fiscal_country_id.code', string='Country code')
     company_price_include = fields.Selection(related='company_id.account_price_include')
     duplicated_order_ids = fields.Many2many(comodel_name='sale.order', compute='_compute_duplicated_order_ids')
-    expected_date = fields.Datetime(
-        string="Expected Date",
-        compute='_compute_expected_date', store=False,  # Note: can not be stored since depends on today()
-        help="Delivery date you can promise to the customer, computed from the minimum lead time of the order lines.")
-    is_expired = fields.Boolean(string="Is Expired", compute='_compute_is_expired')
-    partner_credit_warning = fields.Text(
-        compute='_compute_partner_credit_warning')
-    tax_calculation_rounding_method = fields.Selection(
-        related='company_id.tax_calculation_rounding_method',
-        depends=['company_id'])
-    tax_country_id = fields.Many2one(
-        comodel_name='res.country',
-        compute='_compute_tax_country_id',
-        # Avoid access error on fiscal position when reading a sale order with company != user.company_ids
-        compute_sudo=True)  # used to filter available taxes depending on the fiscal country and position
+    expected_date = fields.Datetime(string='Expected Date', compute='_compute_expected_date', store=False, help='Delivery date you can promise to the customer, computed from the minimum lead time of the order lines.')
+    is_expired = fields.Boolean(string='Is Expired', compute='_compute_is_expired')
+    partner_credit_warning = fields.Text(compute='_compute_partner_credit_warning')
+    tax_calculation_rounding_method = fields.Selection(related='company_id.tax_calculation_rounding_method', depends=['company_id'])
+    tax_country_id = fields.Many2one(comodel_name='res.country', compute='_compute_tax_country_id', compute_sudo=True)
     tax_totals = fields.Binary(compute='_compute_tax_totals', exportable=False)
     terms_type = fields.Selection(related='company_id.terms_type')
-    type_name = fields.Char(string="Type Name", compute='_compute_type_name')
-
-    # Remaining ux fields (not computed, not stored)
-
-    show_update_fpos = fields.Boolean(
-        string="Has Fiscal Position Changed", store=False)  # True if the fiscal position was changed
-    has_active_pricelist = fields.Boolean(
-        compute='_compute_has_active_pricelist')
-    show_update_pricelist = fields.Boolean(
-        string="Has Pricelist Changed", store=False)  # True if the pricelist was changed
-
-    _date_order_id_idx = models.Index("(date_order desc, id desc)")
-
-    #=== COMPUTE METHODS ===#
+    type_name = fields.Char(string='Type Name', compute='_compute_type_name')
+    show_update_fpos = fields.Boolean(string='Has Fiscal Position Changed', store=False)
+    has_active_pricelist = fields.Boolean(compute='_compute_has_active_pricelist')
+    show_update_pricelist = fields.Boolean(string='Has Pricelist Changed', store=False)
+    _date_order_id_idx = models.Index('(date_order desc, id desc)')
 
     @api.depends('partner_id')
     @api.depends_context('sale_show_partner_name')
@@ -343,9 +108,7 @@ class SaleOrder(models.Model):
     @api.depends('order_line.product_id')
     def _compute_has_archived_products(self):
         for order in self:
-            order.has_archived_products = any(
-                not product.active for product in order.order_line.product_id
-            )
+            order.has_archived_products = any((not product.active for product in order.order_line.product_id))
 
     @api.depends('company_id')
     def _compute_require_signature(self):
@@ -363,7 +126,7 @@ class SaleOrder(models.Model):
             order.prepayment_percent = order.company_id.prepayment_percent
 
     @api.depends('company_id')
-    def _compute_validity_date(self):
+    def _compute_date_validity(self):
         today = fields.Date.context_today(self)
         for order in self:
             days = order.company_id.quotation_validity_days
@@ -419,9 +182,7 @@ class SaleOrder(models.Model):
             fpos_id_before = order.fiscal_position_id.id
             key = (order.company_id.id, order.partner_id.id, order.partner_shipping_id.id)
             if key not in cache:
-                cache[key] = self.env['account.fiscal.position'].with_company(
-                    order.company_id
-                )._get_fiscal_position(order.partner_id, order.partner_shipping_id).id
+                cache[key] = self.env['account.fiscal.position'].with_company(order.company_id)._get_fiscal_position(order.partner_id, order.partner_shipping_id).id
             if fpos_id_before != cache[key] and order.order_line:
                 order.show_update_fpos = True
             order.fiscal_position_id = cache[key]
@@ -457,33 +218,18 @@ class SaleOrder(models.Model):
     @api.depends('currency_id', 'date_order', 'company_id')
     def _compute_currency_rate(self):
         for order in self:
-            order.currency_rate = self.env['res.currency']._get_conversion_rate(
-                from_currency=order.company_id.currency_id,
-                to_currency=order.currency_id,
-                company=order.company_id,
-                date=(order.date_order or fields.Datetime.now()).date(),
-            )
+            order.currency_rate = self.env['res.currency']._get_conversion_rate(from_currency=order.company_id.currency_id, to_currency=order.currency_id, company=order.company_id, date=(order.date_order or fields.Datetime.now()).date())
 
     @api.depends('company_id')
     def _compute_has_active_pricelist(self):
         for order in self:
-            order.has_active_pricelist = bool(self.env['product.pricelist'].search(
-                [('company_id', 'in', (False, order.company_id.id)), ('active', '=', True)],
-                limit=1,
-            ))
+            order.has_active_pricelist = bool(self.env['product.pricelist'].search([('company_id', 'in', (False, order.company_id.id)), ('active', '=', True)], limit=1))
 
     @api.depends('partner_id')
     def _compute_user_id(self):
         for order in self:
-            if order.partner_id and not (order._origin.id and order.user_id):
-                # Recompute the salesman on partner change
-                #   * if partner is set (is required anyway, so it will be set sooner or later)
-                #   * if the order is not saved or has no salesman already
-                order.user_id = (
-                    order.partner_id.user_id
-                    or order.partner_id.commercial_partner_id.user_id
-                    or (self.env.user.has_group('sales_team.group_sale_salesman') and self.env.user)
-                )
+            if order.partner_id and (not (order._origin.id and order.user_id)):
+                order.user_id = order.partner_id.user_id or order.partner_id.commercial_partner_id.user_id or (self.env.user.has_group('sales_team.group_sale_salesman') and self.env.user)
 
     @api.depends('user_id')
     def _compute_team_id(self):
@@ -494,12 +240,7 @@ class SaleOrder(models.Model):
             company_id = order.company_id.id
             key = (default_team_id, user_id, company_id)
             if key not in cached_teams:
-                cached_teams[key] = self.env['crm.team'].with_context(
-                    default_team_id=default_team_id,
-                )._get_default_team_id(
-                    user_id=user_id,
-                    domain=self.env['crm.team']._check_company_domain(company_id),
-                )
+                cached_teams[key] = self.env['crm.team'].with_context(default_team_id=default_team_id)._get_default_team_id(user_id=user_id, domain=self.env['crm.team']._check_company_domain(company_id))
             order.team_id = cached_teams[key]
 
     def _default_team_id(self):
@@ -514,11 +255,7 @@ class SaleOrder(models.Model):
             base_lines += order._add_base_lines_for_early_payment_discount()
             AccountTax._add_tax_details_in_base_lines(base_lines, order.company_id)
             AccountTax._round_base_lines_tax_details(base_lines, order.company_id)
-            tax_totals = AccountTax._get_tax_totals_summary(
-                base_lines=base_lines,
-                currency=order.currency_id or order.company_id.currency_id,
-                company=order.company_id,
-            )
+            tax_totals = AccountTax._get_tax_totals_summary(base_lines=base_lines, currency=order.currency_id or order.company_id.currency_id, company=order.company_id)
             order.amount_untaxed = tax_totals['base_amount_currency']
             order.amount_tax = tax_totals['tax_amount_currency']
             order.amount_total = tax_totals['total_amount_currency']
@@ -532,40 +269,17 @@ class SaleOrder(models.Model):
         """
         self.ensure_one()
         epd_lines = []
-        if (
-            self.payment_term_id.early_discount
-            and self.payment_term_id.early_pay_discount_computation == 'mixed'
-            and self.payment_term_id.discount_percentage
-        ):
+        if self.payment_term_id.early_discount and self.payment_term_id.early_pay_discount_computation == 'mixed' and self.payment_term_id.discount_percentage:
             percentage = self.payment_term_id.discount_percentage
             currency = self.currency_id or self.company_id.currency_id
             for line in self.order_line.filtered(lambda x: not x.display_type):
-                line_amount_after_discount = (line.price_subtotal / 100) * percentage
-                epd_lines.append(self.env['account.tax']._prepare_base_line_for_taxes_computation(
-                    record=self,
-                    price_unit=-line_amount_after_discount,
-                    quantity=1.0,
-                    currency_id=currency,
-                    sign=1,
-                    special_type='early_payment',
-                    tax_ids=line.tax_ids.flatten_taxes_hierarchy().filtered(lambda tax: tax.amount_type != 'fixed'),
-                ))
-                epd_lines.append(self.env['account.tax']._prepare_base_line_for_taxes_computation(
-                    record=self,
-                    price_unit=line_amount_after_discount,
-                    quantity=1.0,
-                    currency_id=currency,
-                    sign=1,
-                    special_type='early_payment',
-                ))
+                line_amount_after_discount = line.price_subtotal / 100 * percentage
+                epd_lines.append(self.env['account.tax']._prepare_base_line_for_taxes_computation(record=self, price_unit=-line_amount_after_discount, quantity=1.0, currency_id=currency, sign=1, special_type='early_payment', tax_ids=line.tax_ids.flatten_taxes_hierarchy().filtered(lambda tax: tax.amount_type != 'fixed')))
+                epd_lines.append(self.env['account.tax']._prepare_base_line_for_taxes_computation(record=self, price_unit=line_amount_after_discount, quantity=1.0, currency_id=currency, sign=1, special_type='early_payment'))
         return epd_lines
 
     @api.depends('order_line.invoice_lines')
     def _get_invoiced(self):
-        # The invoice_ids are obtained thanks to the invoice lines of the SO
-        # lines, and we also search for possible refunds created directly from
-        # existing invoices. This is necessary since such a refund is not
-        # directly linked to the SO.
         for order in self:
             invoices = order.order_line.invoice_lines.move_id.filtered(lambda r: r.move_type in ('out_invoice', 'out_refund'))
             order.invoice_ids = invoices
@@ -577,37 +291,13 @@ class SaleOrder(models.Model):
         if operator == 'in' and value:
             falsy_domain = []
             if False in value:
-                # special case for [('invoice_ids', '=', False)], i.e. "Invoices is not set"
-                #
-                # We cannot just search [('order_line.invoice_lines', '=', False)]
-                # because it returns orders with uninvoiced lines, which is not
-                # same "Invoices is not set" (some lines may have invoices and some
-                # don't)
-                #
-                # A solution is using the 'not any' operators with inverted search first
-                # ("orders with invoiced lines").
-                falsy_domain = [('order_line', 'not any', [
-                    ('invoice_lines.move_id.move_type', 'in', ('out_invoice', 'out_refund'))
-                ])]
+                falsy_domain = [('line_ids', 'not any', [('invoice_lines.move_id.move_type', 'in', ('out_invoice', 'out_refund'))])]
                 if len(value) == 1:
                     return falsy_domain
-            self.env.cr.execute("""
-                SELECT array_agg(so.id)
-                    FROM sale_order so
-                    JOIN sale_order_line sol ON sol.order_id = so.id
-                    JOIN sale_order_line_invoice_rel soli_rel ON soli_rel.order_line_id = sol.id
-                    JOIN account_move_line aml ON aml.id = soli_rel.invoice_line_id
-                    JOIN account_move am ON am.id = aml.move_id
-                WHERE
-                    am.move_type in ('out_invoice', 'out_refund') AND
-                    am.id = ANY(%s)
-            """, (list(value),))
+            self.env.cr.execute("\n                SELECT array_agg(so.id)\n                    FROM sale_order so\n                    JOIN sale_order_line sol ON sol.order_id = so.id\n                    JOIN sale_order_line_invoice_rel soli_rel ON soli_rel.order_line_id = sol.id\n                    JOIN account_move_line aml ON aml.id = soli_rel.invoice_line_id\n                    JOIN account_move am ON am.id = aml.move_id\n                WHERE\n                    am.move_type in ('out_invoice', 'out_refund') AND\n                    am.id = ANY(%s)\n            ", (list(value),))
             so_ids = self.env.cr.fetchone()[0] or []
             return [('id', 'in', so_ids)] + falsy_domain
-        return [('order_line.invoice_lines', 'any', [
-            ('move_id.move_type', 'in', ('out_invoice', 'out_refund')),
-            ('move_id', operator, value),
-        ])]
+        return [('order_line.invoice_lines', 'any', [('move_id.move_type', 'in', ('out_invoice', 'out_refund')), ('move_id', operator, value)])]
 
     @api.depends('state', 'order_line.invoice_status')
     def _compute_invoice_status(self):
@@ -624,35 +314,25 @@ class SaleOrder(models.Model):
         if not confirmed_orders:
             return
         lines_domain = [('is_downpayment', '=', False), ('display_type', '=', False)]
-        line_invoice_status_all = [
-            (order.id, invoice_status)
-            for order, invoice_status in self.env['sale.order.line']._read_group(
-                lines_domain + [('order_id', 'in', confirmed_orders.ids)],
-                ['order_id', 'invoice_status']
-            )
-        ]
+        line_invoice_status_all = [(order.id, invoice_status) for order, invoice_status in self.env['sale.order.line']._read_group(lines_domain + [('order_id', 'in', confirmed_orders.ids)], ['order_id', 'invoice_status'])]
         for order in confirmed_orders:
             line_invoice_status = [d[1] for d in line_invoice_status_all if d[0] == order.id]
             if order.state != 'sale':
                 order.invoice_status = 'no'
-            elif any(invoice_status == 'to invoice' for invoice_status in line_invoice_status):
-                if any(invoice_status == 'no' for invoice_status in line_invoice_status):
-                    # If only discount/delivery/promotion lines can be invoiced, the SO should not
-                    # be invoiceable.
-                    invoiceable_domain = lines_domain + [('invoice_status', '=', 'to invoice')]
+            elif any((invoice_status == 'to invoice' for invoice_status in line_invoice_status)):
+                if any((invoice_status == 'no' for invoice_status in line_invoice_status)):
+                    invoiceable_domain = lines_domain + [('invoice_state', '=', 'to invoice')]
                     invoiceable_lines = order.order_line.filtered_domain(invoiceable_domain)
-                    special_lines = invoiceable_lines.filtered(
-                        lambda sol: not sol._can_be_invoiced_alone()
-                    )
+                    special_lines = invoiceable_lines.filtered(lambda sol: not sol._can_be_invoiced_alone())
                     if invoiceable_lines == special_lines:
                         order.invoice_status = 'no'
                     else:
                         order.invoice_status = 'to invoice'
                 else:
                     order.invoice_status = 'to invoice'
-            elif line_invoice_status and all(invoice_status == 'invoiced' for invoice_status in line_invoice_status):
+            elif line_invoice_status and all((invoice_status == 'invoiced' for invoice_status in line_invoice_status)):
                 order.invoice_status = 'invoiced'
-            elif line_invoice_status and all(invoice_status in ('invoiced', 'upselling') for invoice_status in line_invoice_status):
+            elif line_invoice_status and all((invoice_status in ('invoiced', 'upselling') for invoice_status in line_invoice_status)):
                 order.invoice_status = 'upselling'
             else:
                 order.invoice_status = 'no'
@@ -667,15 +347,13 @@ class SaleOrder(models.Model):
     def _compute_amount_paid(self):
         """ Sum of the amount paid through all transactions for this SO. """
         for order in self:
-            order.amount_paid = sum(
-                tx.amount for tx in order.transaction_ids if tx.state in ('authorized', 'done')
-            )
+            order.amount_paid = sum((tx.amount for tx in order.transaction_ids if tx.state in ('authorized', 'done')))
 
     def _compute_amount_undiscounted(self):
         for order in self:
             total = 0.0
             for line in order.order_line:
-                total += (line.price_subtotal * 100)/(100-line.discount) if line.discount != 100 else (line.price_unit * line.product_uom_qty)
+                total += line.price_subtotal * 100 / (100 - line.discount) if line.discount != 100 else line.price_unit * line.product_uom_qty
             order.amount_undiscounted = total
 
     @api.depends('client_order_ref', 'origin', 'partner_id')
@@ -695,46 +373,21 @@ class SaleOrder(models.Model):
         orders = self.filtered(lambda order: order.id and order.client_order_ref)
         if not orders:
             return {}
-
         self.env['sale.order'].flush_model(['company_id', 'partner_id', 'client_order_ref', 'origin', 'state'])
-
-        result = self.env.execute_query(SQL("""
-            SELECT
-                sale_order.id AS order_id,
-                array_agg(duplicate_order.id) AS duplicate_ids
-              FROM sale_order
-              JOIN sale_order AS duplicate_order
-                ON sale_order.company_id = duplicate_order.company_id
-                 AND sale_order.id != duplicate_order.id
-                 AND duplicate_order.state != 'cancel'
-                 AND sale_order.partner_id = duplicate_order.partner_id
-                 AND (
-                    sale_order.origin = duplicate_order.name
-                    OR sale_order.client_order_ref = duplicate_order.client_order_ref
-                )
-             WHERE sale_order.id IN %(orders)s
-             GROUP BY sale_order.id
-            """,
-            orders=tuple(orders.ids),
-        ))
-        return {
-            order_id: set(duplicate_ids)
-            for order_id, duplicate_ids in result
-        }
+        result = self.env.execute_query(SQL("\n            SELECT\n                sale_order.id AS order_id,\n                array_agg(duplicate_order.id) AS duplicate_ids\n              FROM sale_order\n              JOIN sale_order AS duplicate_order\n                ON sale_order.company_id = duplicate_order.company_id\n                 AND sale_order.id != duplicate_order.id\n                 AND duplicate_order.state != 'cancel'\n                 AND sale_order.partner_id = duplicate_order.partner_id\n                 AND (\n                    sale_order.origin = duplicate_order.name\n                    OR sale_order.client_order_ref = duplicate_order.client_order_ref\n                )\n             WHERE sale_order.id IN %(orders)s\n             GROUP BY sale_order.id\n            ", orders=tuple(orders.ids)))
+        return {order_id: set(duplicate_ids) for order_id, duplicate_ids in result}
 
     @api.depends('order_line.customer_lead', 'date_order', 'state')
     def _compute_expected_date(self):
         """ For service and combo (non-goods) products, we avoid computing the expected date. This method is extended in sale_stock to
             take the picking_policy of SO into account.
         """
-        self.mapped("order_line")  # Prefetch indication
+        self.mapped('line_ids')
         for order in self:
             if order.state == 'cancel':
                 order.expected_date = False
                 continue
-            dates_list = order.order_line.filtered(
-                lambda line: line.product_id.type == 'consu' and not line.display_type and not line._is_delivery()
-            ).mapped(lambda line: line and line._expected_date())
+            dates_list = order.order_line.filtered(lambda line: line.product_id.type == 'consu' and (not line.display_type) and (not line._is_delivery())).mapped(lambda line: line and line._expected_date())
             if dates_list:
                 order.expected_date = order._select_expected_date(dates_list)
             else:
@@ -747,11 +400,7 @@ class SaleOrder(models.Model):
     def _compute_is_expired(self):
         today = fields.Date.today()
         for order in self:
-            order.is_expired = (
-                order.state in ('draft', 'sent')
-                and order.validity_date
-                and order.validity_date < today
-            )
+            order.is_expired = order.state in ('draft', 'sent') and order.validity_date and (order.validity_date < today)
 
     @api.depends('company_id', 'fiscal_position_id')
     def _compute_tax_country_id(self):
@@ -764,25 +413,21 @@ class SaleOrder(models.Model):
     @api.depends('order_line.amount_to_invoice')
     def _compute_amount_to_invoice(self):
         for order in self:
-            order.amount_to_invoice = sum(order.order_line.mapped('amount_to_invoice'))
+            order.amount_to_invoice = sum(order.order_line.mapped('amount_to_invoice_taxinc'))
 
     @api.depends('order_line.amount_invoiced')
     def _compute_amount_invoiced(self):
         for order in self:
-            order.amount_invoiced = sum(order.order_line.mapped('amount_invoiced'))
+            order.amount_invoiced = sum(order.order_line.mapped('amount_invoiced_taxinc'))
 
     @api.depends('company_id', 'partner_id', 'amount_total')
     def _compute_partner_credit_warning(self):
         for order in self:
             order.with_company(order.company_id)
             order.partner_credit_warning = ''
-            show_warning = order.state in ('draft', 'sent') and \
-                           order.company_id.account_use_credit_limit
+            show_warning = order.state in ('draft', 'sent') and order.company_id.account_use_credit_limit
             if show_warning:
-                order.partner_credit_warning = self.env['account.move']._build_credit_warning_message(
-                    order.sudo(),  # ensure access to `credit` & `credit_limit` fields
-                    current_amount=(order.amount_total / order.currency_rate),
-                )
+                order.partner_credit_warning = self.env['account.move']._build_credit_warning_message(order.sudo(), current_amount=order.amount_total / order.currency_rate)
 
     @api.depends_context('lang')
     @api.depends('order_line.price_subtotal', 'currency_id', 'company_id', 'payment_term_id')
@@ -794,21 +439,16 @@ class SaleOrder(models.Model):
             base_lines += order._add_base_lines_for_early_payment_discount()
             AccountTax._add_tax_details_in_base_lines(base_lines, order.company_id)
             AccountTax._round_base_lines_tax_details(base_lines, order.company_id)
-            order.tax_totals = AccountTax._get_tax_totals_summary(
-                base_lines=base_lines,
-                currency=order.currency_id or order.company_id.currency_id,
-                company=order.company_id,
-            )
+            order.tax_totals = AccountTax._get_tax_totals_summary(base_lines=base_lines, currency=order.currency_id or order.company_id.currency_id, company=order.company_id)
 
     @api.depends('state')
     def _compute_type_name(self):
         for record in self:
             if record.state in ('draft', 'sent', 'cancel'):
-                record.type_name = _("Quotation")
+                record.type_name = _('Quotation')
             else:
-                record.type_name = _("Sales Order")
+                record.type_name = _('Sales Order')
 
-    # portal.mixin override
     def _compute_access_url(self):
         super()._compute_access_url()
         for order in self:
@@ -818,62 +458,38 @@ class SaleOrder(models.Model):
     def _compute_sale_warning_text(self):
         for order in self:
             warnings = OrderedSet()
-            if partner_msg := order.partner_id.sale_warn_msg:
+            if (partner_msg := order.partner_id.sale_warn_msg):
                 warnings.add(order.partner_id.name + ' - ' + partner_msg)
             for line in order.order_line:
-                if product_msg := line.sale_line_warn_msg:
+                if (product_msg := line.sale_line_warn_msg):
                     warnings.add(line.product_id.display_name + ' - ' + product_msg)
             order.sale_warning_text = '\n'.join(warnings)
 
-    #=== CONSTRAINT METHODS ===#
-
     @api.constrains('company_id', 'order_line')
     def _check_order_line_company_id(self):
         for order in self:
-            invalid_companies = order.order_line.product_id.company_id.filtered(
-                lambda c: order.company_id not in c._accessible_branches()
-            )
+            invalid_companies = order.order_line.product_id.company_id.filtered(lambda c: order.company_id not in c._accessible_branches())
             if invalid_companies:
-                bad_products = order.order_line.product_id.filtered(
-                    lambda p: p.company_id and p.company_id in invalid_companies
-                )
-                raise ValidationError(_(
-                    "Your quotation contains products from company %(product_company)s whereas your quotation belongs to company %(quote_company)s. \n Please change the company of your quotation or remove the products from other companies (%(bad_products)s).",
-                    product_company=', '.join(invalid_companies.sudo().mapped('display_name')),
-                    quote_company=order.company_id.display_name,
-                    bad_products=', '.join(bad_products.mapped('display_name')),
-                ))
+                bad_products = order.order_line.product_id.filtered(lambda p: p.company_id and p.company_id in invalid_companies)
+                raise ValidationError(_('Your quotation contains products from company %(product_company)s whereas your quotation belongs to company %(quote_company)s. \n Please change the company of your quotation or remove the products from other companies (%(bad_products)s).', product_company=', '.join(invalid_companies.sudo().mapped('display_name')), quote_company=order.company_id.display_name, bad_products=', '.join(bad_products.mapped('display_name'))))
 
     @api.constrains('prepayment_percent')
     def _check_prepayment_percent(self):
         for order in self:
-            if order.require_payment and not (0 < order.prepayment_percent <= 1.0):
-                raise ValidationError(_("Prepayment percentage must be a valid percentage."))
-
-    #=== ONCHANGE METHODS ===#
+            if order.require_payment and (not 0 < order.prepayment_percent <= 1.0):
+                raise ValidationError(_('Prepayment percentage must be a valid percentage.'))
 
     def onchange(self, values, field_names, fields_spec):
         self_with_context = self
         if not field_names:
-            self_with_context = self.with_context(
-                # Some warnings should not be displayed for the first onchange
-                sale_onchange_first_call=True,
-                # invoice & delivery address with higher `customer_rank` should take priority
-                res_partner_search_mode='customer',
-            )
+            self_with_context = self.with_context(sale_onchange_first_call=True, res_partner_search_mode='customer')
         return super(SaleOrder, self_with_context).onchange(values, field_names, fields_spec)
 
-    @api.onchange('commitment_date', 'expected_date')
-    def _onchange_commitment_date(self):
+    @api.onchange('date_commitment', 'expected_date')
+    def _onchange_date_commitment(self):
         """ Warn if the commitment dates is sooner than the expected date """
-        if self.commitment_date and self.expected_date and self.commitment_date < self.expected_date:
-            return {
-                'warning': {
-                    'title': _('Requested date is too soon.'),
-                    'message': _("The delivery date is sooner than the expected date."
-                                 " You may be unable to honor the delivery date.")
-                }
-            }
+        if self.commitment_date and self.expected_date and (self.commitment_date < self.expected_date):
+            return {'warning': {'title': _('Requested date is too soon.'), 'message': _('The delivery date is sooner than the expected date. You may be unable to honor the delivery date.')}}
 
     @api.onchange('company_id')
     def _onchange_company_id_warning(self):
@@ -881,29 +497,17 @@ class SaleOrder(models.Model):
         if self.env.context.get('sale_onchange_first_call'):
             return
         if self.order_line and self.state == 'draft':
-            return {
-                'warning': {
-                    'title': _("Warning for the change of your quotation's company"),
-                    'message': _("Changing the company of an existing quotation might need some "
-                                 "manual adjustments in the details of the lines. You might "
-                                 "consider updating the prices."),
-                }
-            }
+            return {'warning': {'title': _("Warning for the change of your quotation's company"), 'message': _('Changing the company of an existing quotation might need some manual adjustments in the details of the lines. You might consider updating the prices.')}}
 
     @api.onchange('company_id')
     def _onchange_company_id(self):
         for order in self:
-            # This can't be caught by a python constraint as it is only triggered at save
-            # and a compute methodd needs this data to be set correctly before saving
             if not order.company_id:
-                raise ValidationError(_("The company is required, please select one before making any other changes to the sale order."))
+                raise ValidationError(_('The company is required, please select one before making any other changes to the sale order.'))
 
     @api.onchange('fiscal_position_id')
     def _onchange_fpos_id_show_update_fpos(self):
-        if self.order_line and (
-            not self.fiscal_position_id
-            or (self.fiscal_position_id and self._origin.fiscal_position_id != self.fiscal_position_id)
-        ):
+        if self.order_line and (not self.fiscal_position_id or (self.fiscal_position_id and self._origin.fiscal_position_id != self.fiscal_position_id)):
             self.show_update_fpos = True
 
     @api.onchange('pricelist_id')
@@ -915,7 +519,7 @@ class SaleOrder(models.Model):
         if not self.prepayment_percent:
             self.require_payment = False
 
-    @api.onchange('order_line')
+    @api.onchange('line_ids')
     def _onchange_order_line(self):
         for index, line in enumerate(self.order_line):
             if line.product_type != 'combo':
@@ -923,169 +527,76 @@ class SaleOrder(models.Model):
             combo_item_lines = line._get_linked_lines().filtered('combo_item_id')
             if line.selected_combo_items:
                 selected_combo_items = json.loads(line.selected_combo_items)
-                if (
-                    selected_combo_items
-                    and len(selected_combo_items) != len(line.product_template_id.sudo().combo_ids)
-                ):
-                    raise ValidationError(_(
-                        "The number of selected combo items must match the number of available"
-                        " combo choices."
-                    ))
-
-                # Delete any existing combo item lines.
+                if selected_combo_items and len(selected_combo_items) != len(line.product_template_id.sudo().combo_ids):
+                    raise ValidationError(_('The number of selected combo items must match the number of available combo choices.'))
                 delete_commands = [Command.delete(linked_line.id) for linked_line in combo_item_lines]
-                # Create a new combo item line for each selected combo item.
-                create_commands = [Command.create({
-                    'product_id': combo_item['product_id'],
-                    'product_uom_qty': line.product_uom_qty,
-                    'combo_item_id': combo_item['combo_item_id'],
-                    'product_no_variant_attribute_value_ids': [
-                        Command.set(combo_item['no_variant_attribute_value_ids'])
-                    ],
-                    'product_custom_attribute_value_ids': [Command.clear()] + [
-                        Command.create(attribute_value)
-                        for attribute_value in combo_item['product_custom_attribute_values']
-                    ],
-                    # Combo item lines should come directly after their combo product line.
-                    'sequence': line.sequence + item_index + 1,
-                    # If the linked line exists in DB, populate linked_line_id, otherwise populate
-                    # linked_virtual_id.
-                    'linked_line_id': line.id if line._origin else False,
-                    'linked_virtual_id': line.virtual_id if not line._origin else False,
-                }) for item_index, combo_item in enumerate(selected_combo_items)]
-                # Shift any lines coming after the combo product line so that the combo item lines
-                # come first.
-                update_commands = [Command.update(
-                    order_line.id,
-                    {'sequence': order_line.sequence + len(selected_combo_items)},
-                ) for order_line in self.order_line if order_line.sequence > line.sequence]
-
-                # Clear `selected_combo_items` to avoid applying the same changes multiple times.
+                create_commands = [Command.create({'product_id': combo_item['product_id'], 'product_uom_qty': line.product_uom_qty, 'combo_item_id': combo_item['combo_item_id'], 'product_no_variant_attribute_value_ids': [Command.set(combo_item['no_variant_attribute_value_ids'])], 'product_custom_attribute_value_ids': [Command.clear()] + [Command.create(attribute_value) for attribute_value in combo_item['product_custom_attribute_values']], 'sequence': line.sequence + item_index + 1, 'linked_line_id': line.id if line._origin else False, 'linked_virtual_id': line.virtual_id if not line._origin else False}) for item_index, combo_item in enumerate(selected_combo_items)]
+                update_commands = [Command.update(order_line.id, {'sequence': order_line.sequence + len(selected_combo_items)}) for order_line in self.order_line if order_line.sequence > line.sequence]
                 line.selected_combo_items = False
                 self.order_line = delete_commands + create_commands + update_commands
             elif combo_item_lines:
-                combo_item_lines.update({
-                    'product_uom_qty': line.product_uom_qty,
-                    'discount': line.discount,
-                })
-
-    #=== CRUD METHODS ===#
+                combo_item_lines.update({'product_uom_qty': line.product_uom_qty, 'discount': line.discount})
 
     @api.model_create_multi
     def create(self, vals_list):
         for vals in vals_list:
-            if vals.get('name', _("New")) == _("New"):
-                seq_date = fields.Datetime.context_timestamp(
-                    self, fields.Datetime.to_datetime(vals['date_order'])
-                ) if 'date_order' in vals else None
-                vals['name'] = self.env['ir.sequence'].with_company(vals.get('company_id')).next_by_code(
-                    'sale.order', sequence_date=seq_date) or _("New")
-
+            if vals.get('name', _('New')) == _('New'):
+                seq_date = fields.Datetime.context_timestamp(self, fields.Datetime.to_datetime(vals['date_order'])) if 'date_order' in vals else None
+                vals['name'] = self.env['ir.sequence'].with_company(vals.get('company_id')).next_by_code('sale.order', sequence_date=seq_date) or _('New')
         return super().create(vals_list)
 
-    def _get_copiable_order_lines(self):
+    def _get_order_lines_copiable(self):
         """Returns the order lines that can be copied to a new order."""
         return self.order_line.filtered(lambda l: not l.is_downpayment)
 
     def copy_data(self, default=None):
         default = dict(default or {})
         default_has_no_order_line = 'order_line' not in default
-        default.setdefault('order_line', [])
+        default.setdefault('line_ids', [])
         vals_list = super().copy_data(default=default)
         if default_has_no_order_line:
             for order, vals in zip(self, vals_list):
-                vals['order_line'] = [
-                    Command.create(line_vals)
-                    for line_vals in order._get_copiable_order_lines().copy_data()
-                ]
+                vals['order_line'] = [Command.create(line_vals) for line_vals in order._get_copiable_order_lines().copy_data()]
         return vals_list
 
     @api.ondelete(at_uninstall=False)
     def _unlink_except_draft_or_cancel(self):
         for order in self:
             if order.state not in ('draft', 'cancel'):
-                raise UserError(_(
-                    "You can not delete a sent quotation or a confirmed sales order."
-                    " You must first cancel it."))
+                raise UserError(_('You can not delete a sent quotation or a confirmed sales order. You must first cancel it.'))
 
     def write(self, vals):
-        if 'pricelist_id' in vals and any(so.state == 'sale' for so in self):
-            raise UserError(_("You cannot change the pricelist of a confirmed order !"))
+        if 'pricelist_id' in vals and any((so.state == 'sale' for so in self)):
+            raise UserError(_('You cannot change the pricelist of a confirmed order !'))
         return super().write(vals)
 
-    #=== ACTION METHODS ===#
-
     @api.readonly
     def action_open_discount_wizard(self):
         self.ensure_one()
-        return {
-            'name': _("Discount"),
-            'type': 'ir.actions.act_window',
-            'res_model': 'sale.order.discount',
-            'view_mode': 'form',
-            'target': 'new',
-        }
+        return {'name': _('Discount'), 'type': 'ir.actions.act_window', 'res_model': 'sale.order.discount', 'view_mode': 'form', 'target': 'new'}
 
     def action_draft(self):
         orders = self.filtered(lambda s: s.state in ['cancel', 'sent'])
-        return orders.write({
-            'state': 'draft',
-            'signature': False,
-            'signed_by': False,
-            'signed_on': False,
-        })
-
-    def action_quotation_send(self):
+        return orders.write({'state': 'draft', 'signature': False, 'signed_by': False, 'signed_on': False})
+
+    def action_send_quotation(self):
         """ Opens a wizard to compose an email, with relevant mail template loaded by default """
         self.filtered(lambda so: so.state in ('draft', 'sent')).order_line._validate_analytic_distribution()
-
-        ctx = {
-            'default_model': 'sale.order',
-            'default_res_ids': self.ids,
-            'default_composition_mode': 'comment',
-            'default_email_layout_xmlid': 'mail.mail_notification_layout_with_responsible_signature',
-            'email_notification_allow_footer': True,
-            'hide_mail_template_management_options': True,
-            'proforma': self.env.context.get('proforma', False),
-        }
-
+        ctx = {'default_model': 'sale.order', 'default_res_ids': self.ids, 'default_composition_mode': 'comment', 'default_email_layout_xmlid': 'mail.mail_notification_layout_with_responsible_signature', 'email_notification_allow_footer': True, 'hide_mail_template_management_options': True, 'proforma': self.env.context.get('proforma', False)}
         if len(self) > 1:
             ctx['default_composition_mode'] = 'mass_mail'
         else:
-            ctx.update({
-                'force_email': True,
-            })
+            ctx.update({'force_email': True})
             if not self.env.context.get('hide_default_template'):
                 mail_template = self._find_mail_template()
                 if mail_template:
-                    ctx.update({
-                        'default_template_id': mail_template.id,
-                        'mark_so_as_sent': True,
-                    })
+                    ctx.update({'default_template_id': mail_template.id, 'mark_so_as_sent': True})
             else:
                 for order in self:
                     order._portal_ensure_token()
-
-        action = {
-            'name': _('Send'),
-            'type': 'ir.actions.act_window',
-            'view_mode': 'form',
-            'res_model': 'mail.compose.message',
-            'views': [(False, 'form')],
-            'view_id': False,
-            'target': 'new',
-            'context': ctx,
-        }
-        if (
-            self.env.context.get('check_document_layout')
-            and not self.env.context.get('discard_logo_check')
-            and self.env.is_admin()
-            and not self.env.company.external_report_layout_id
-        ):
-            layout_action = self.env['ir.actions.report']._action_configure_external_report_layout(
-                action,
-            )
-            # Need to remove this context for windows action
+        action = {'name': _('Send'), 'type': 'ir.actions.act_window', 'view_mode': 'form', 'res_model': 'mail.compose.message', 'views': [(False, 'form')], 'view_id': False, 'target': 'new', 'context': ctx}
+        if self.env.context.get('check_document_layout') and (not self.env.context.get('discard_logo_check')) and self.env.is_admin() and (not self.env.company.external_report_layout_id):
+            layout_action = self.env['ir.actions.report']._action_configure_external_report_layout(action)
             action.pop('close_on_report_download', None)
             layout_action['context']['dialog_size'] = 'extra-large'
             return layout_action
@@ -1114,11 +625,8 @@ class SaleOrder(models.Model):
         :return: `mail.template` record or None if default template wasn't found
         """
         self.ensure_one()
-        default_confirmation_template_id = self.env['ir.config_parameter'].sudo().get_param(
-            'sale.default_confirmation_template'
-        )
-        default_confirmation_template = default_confirmation_template_id \
-            and self.env['mail.template'].browse(int(default_confirmation_template_id)).exists()
+        default_confirmation_template_id = self.env['ir.config_parameter'].sudo().get_param('sale.default_confirmation_template')
+        default_confirmation_template = default_confirmation_template_id and self.env['mail.template'].browse(int(default_confirmation_template_id)).exists()
         if default_confirmation_template:
             return default_confirmation_template
         else:
@@ -1129,9 +637,8 @@ class SaleOrder(models.Model):
 
         :raise: UserError if any given SO is not in draft state.
         """
-        if any(order.state != 'draft' for order in self):
-            raise UserError(_("Only draft orders can be marked as sent directly."))
-
+        if any((order.state != 'draft' for order in self)):
+            raise UserError(_('Only draft orders can be marked as sent directly.'))
         self.write({'state': 'sent'})
 
     def action_confirm(self):
@@ -1147,43 +654,28 @@ class SaleOrder(models.Model):
             error_msg = order._confirmation_error_message()
             if error_msg:
                 raise UserError(error_msg)
-
         self.order_line._validate_analytic_distribution()
-
         self.write(self._prepare_confirmation_values())
-
-        # Context key 'default_name' is sometimes propagated up to here.
-        # We don't need it and it creates issues in the creation of linked records.
         context = self.env.context.copy()
         context.pop('default_name', None)
         context.pop('default_user_id', None)
-
         self.with_context(context)._action_confirm()
         self.filtered(lambda so: so._should_be_locked()).action_lock()
-
         if self.env.context.get('send_email'):
             self._send_order_confirmation_mail()
-
         return True
 
     def _should_be_locked(self):
         self.ensure_one()
-        # Public user can confirm SO, so we check the group on any record creator.
         return self.env['res.groups']._is_feature_enabled('sale.group_auto_done_setting')
 
     def _confirmation_error_message(self):
         """ Return whether order can be confirmed or not if not then returm error message. """
         self.ensure_one()
         if self.state not in {'draft', 'sent'}:
-            return _("Some orders are not in a state requiring confirmation.")
-        if any(
-            not line.display_type
-            and not line.is_downpayment
-            and not line.product_id
-            for line in self.order_line
-        ):
-            return _("Some order lines are missing a product, you need to correct them before going further.")
-
+            return _('Some orders are not in a state requiring confirmation.')
+        if any((not line.display_type and (not line.is_downpayment) and (not line.product_id) for line in self.order_line)):
+            return _('Some order lines are missing a product, you need to correct them before going further.')
         return False
 
     def _prepare_confirmation_values(self):
@@ -1194,10 +686,7 @@ class SaleOrder(models.Model):
         :return: Sales Order confirmation values
         :rtype: dict
         """
-        return {
-            'state': 'sale',
-            'date_order': fields.Datetime.now()
-        }
+        return {'state': 'sale', 'date_order': fields.Datetime.now()}
 
     def _action_confirm(self):
         """ Implementation of additional mechanism of Sales Order confirmation.
@@ -1219,9 +708,7 @@ class SaleOrder(models.Model):
 
         :return: None
         """
-        mail_template = self.env.ref(
-            'sale.mail_template_sale_payment_executed', raise_if_not_found=False
-        )
+        mail_template = self.env.ref('sale.mail_template_sale_payment_executed', raise_if_not_found=False)
         for order in self:
             order._send_order_notification_mail(mail_template)
 
@@ -1238,28 +725,18 @@ class SaleOrder(models.Model):
         :return: None
         """
         self.ensure_one()
-
         if not mail_template:
             return
-
         if self.env.su:
-            # sending mail in sudo was meant for it being sent from superuser
             self = self.with_user(SUPERUSER_ID)
-
         async_send = str2bool(self.env['ir.config_parameter'].sudo().get_param('sale.async_emails'))
         cron = self.env.ref('sale.send_pending_emails_cron', raise_if_not_found=False)
         cron_enabled = cron and cron.sudo().active
         if async_send and cron_enabled and allow_deferred_sending:
-            # Schedule the email to be sent asynchronously.
             self.pending_email_template_id = mail_template
             cron._trigger()
-        else:  # Async emails are disabled, either by the user or we are in the cron job.
-            # Send the email synchronously.
-            self.with_context(force_send=True).message_post_with_source(
-                mail_template,
-                email_layout_xmlid='mail.mail_notification_layout_with_responsible_signature',
-                subtype_xmlid='mail.mt_comment',
-            )
+        else:
+            self.with_context(force_send=True).message_post_with_source(mail_template, email_layout_xmlid='mail.mail_notification_layout_with_responsible_signature', subtype_xmlid='mail.mt_comment')
 
     def _validate_order(self):
         """Confirm the sale order and send a confirmation email.
@@ -1277,10 +754,8 @@ class SaleOrder(models.Model):
         pending_email_orders = self.search([('pending_email_template_id', '!=', False)])
         self.env['ir.cron']._commit_progress(remaining=len(pending_email_orders))
         for order in pending_email_orders:
-            order = order[0]  # Avoid pre-fetching after each cache invalidation due to committing.
-            order._send_order_notification_mail(
-                order.pending_email_template_id, allow_deferred_sending=False
-            )  # Resume the email sending.
+            order = order[0]
+            order._send_order_notification_mail(order.pending_email_template_id, allow_deferred_sending=False)
             order.pending_email_template_id = None
             remaining_time = self.env['ir.cron']._commit_progress(processed=1)
             if not remaining_time:
@@ -1294,8 +769,8 @@ class SaleOrder(models.Model):
 
     def action_cancel(self):
         """ Cancel sales order and related draft invoices. """
-        if any(order.locked for order in self):
-            raise UserError(_("You cannot cancel a locked order. Please unlock it first."))
+        if any((order.locked for order in self)):
+            raise UserError(_('You cannot cancel a locked order. Please unlock it first.'))
         return self._action_cancel()
 
     def _action_cancel(self):
@@ -1306,21 +781,13 @@ class SaleOrder(models.Model):
     @api.readonly
     def action_preview_sale_order(self):
         self.ensure_one()
-        return {
-            'type': 'ir.actions.act_url',
-            'target': 'self',
-            'url': self.get_portal_url(),
-        }
+        return {'type': 'ir.actions.act_url', 'target': 'self', 'url': self.get_portal_url()}
 
     def action_update_taxes(self):
         self.ensure_one()
-
         self._recompute_taxes()
-
         if self.partner_id:
-            self.message_post(body=_("Product taxes have been recomputed according to fiscal position %s.",
-                self.fiscal_position_id._get_html_link() if self.fiscal_position_id else "")
-            )
+            self.message_post(body=_('Product taxes have been recomputed according to fiscal position %s.', self.fiscal_position_id._get_html_link() if self.fiscal_position_id else ''))
 
     def _recompute_taxes(self):
         lines_to_recompute = self.order_line.filtered(lambda line: not line.display_type)
@@ -1329,23 +796,17 @@ class SaleOrder(models.Model):
 
     def action_update_prices(self):
         self.ensure_one()
-
         self._recompute_prices()
-
         if self.pricelist_id:
-            message = _("Product prices have been recomputed according to pricelist %s.",
-                self.pricelist_id._get_html_link())
+            message = _('Product prices have been recomputed according to pricelist %s.', self.pricelist_id._get_html_link())
         else:
-            message = _("Product prices have been recomputed.")
+            message = _('Product prices have been recomputed.')
         self.message_post(body=message)
 
     def _recompute_prices(self):
         lines_to_recompute = self._get_update_prices_lines()
         lines_to_recompute.invalidate_recordset(['pricelist_item_id'])
         lines_to_recompute.with_context(force_price_recomputation=True)._compute_price_unit()
-        # Special case: we want to overwrite the existing discount on _recompute_prices call
-        # i.e. to make sure the discount is correctly reset
-        # if pricelist rule is different than when the price was first computed.
         lines_to_recompute.discount = 0.0
         lines_to_recompute._compute_discount()
         self.show_update_pricelist = False
@@ -1356,12 +817,7 @@ class SaleOrder(models.Model):
         return {**default_data, **new_default_data}
 
     def _get_action_add_from_catalog_extra_context(self):
-        return {
-            **super()._get_action_add_from_catalog_extra_context(),
-            'product_catalog_currency_id': self.currency_id.id,
-            'product_catalog_digits': self.order_line._fields['price_unit'].get_digits(self.env),
-            'show_sections': bool(self.id),
-        }
+        return {**super()._get_action_add_from_catalog_extra_context(), 'product_catalog_currency_id': self.currency_id.id, 'product_catalog_digits': self.order_line._fields['price_unit'].get_digits(self.env), 'show_sections': bool(self.id)}
 
     def _get_product_catalog_domain(self):
         return super()._get_product_catalog_domain() & Domain('sale_ok', '=', True)
@@ -1369,15 +825,7 @@ class SaleOrder(models.Model):
     @api.readonly
     def action_open_business_doc(self):
         self.ensure_one()
-        return {
-            'name': _("Order"),
-            'type': 'ir.actions.act_window',
-            'res_model': 'sale.order',
-            'res_id': self.id,
-            'views': [(False, 'form')],
-        }
-
-    # INVOICING #
+        return {'name': _('Order'), 'type': 'ir.actions.act_window', 'res_model': 'sale.order', 'res_id': self.id, 'views': [(False, 'form')]}
 
     def _prepare_invoice(self):
         """
@@ -1386,36 +834,8 @@ class SaleOrder(models.Model):
         a clean extension chain).
         """
         self.ensure_one()
-
-        txs_to_be_linked = self.sudo().transaction_ids.filtered(
-            lambda tx: (
-                tx.state in ('pending', 'authorized')
-                or (tx.state == 'done' and not tx.payment_id.is_reconciled)
-            )
-        )
-
-        values = {
-            'ref': self.client_order_ref or '',
-            'move_type': 'out_invoice',
-            'narration': self.note,
-            'currency_id': self.currency_id.id,
-            'campaign_id': self.campaign_id.id,
-            'medium_id': self.medium_id.id,
-            'source_id': self.source_id.id,
-            'team_id': self.team_id.id,
-            'partner_id': self.partner_invoice_id.id,
-            'partner_shipping_id': self.partner_shipping_id.id,
-            'fiscal_position_id': (self.fiscal_position_id or self.fiscal_position_id._get_fiscal_position(self.partner_invoice_id)).id,
-            'invoice_origin': self.name,
-            'invoice_payment_term_id': self.payment_term_id.id,
-            'preferred_payment_method_line_id': self.preferred_payment_method_line_id.id,
-            'invoice_user_id': self.user_id.id,
-            'payment_reference': self.reference,
-            'transaction_ids': [Command.set(txs_to_be_linked.ids)],
-            'company_id': self.company_id.id,
-            'invoice_line_ids': [],
-            'user_id': self.user_id.id,
-        }
+        txs_to_be_linked = self.sudo().transaction_ids.filtered(lambda tx: tx.state in ('pending', 'authorized') or (tx.state == 'done' and (not tx.payment_id.is_reconciled)))
+        values = {'ref': self.client_order_ref or '', 'move_type': 'out_invoice', 'narration': self.note, 'currency_id': self.currency_id.id, 'campaign_id': self.campaign_id.id, 'medium_id': self.medium_id.id, 'source_id': self.source_id.id, 'team_id': self.team_id.id, 'partner_id': self.partner_invoice_id.id, 'partner_shipping_id': self.partner_shipping_id.id, 'fiscal_position_id': (self.fiscal_position_id or self.fiscal_position_id._get_fiscal_position(self.partner_invoice_id)).id, 'invoice_origin': self.name, 'invoice_payment_term_id': self.payment_term_id.id, 'preferred_payment_method_line_id': self.preferred_payment_method_line_id.id, 'invoice_user_id': self.user_id.id, 'payment_reference': self.reference, 'transaction_ids': [Command.set(txs_to_be_linked.ids)], 'company_id': self.company_id.id, 'invoice_line_ids': [], 'user_id': self.user_id.id}
         if self.journal_id:
             values['journal_id'] = self.journal_id.id
         return values
@@ -1430,23 +850,15 @@ class SaleOrder(models.Model):
         elif len(invoices) == 1:
             form_view = [(self.env.ref('account.view_move_form').id, 'form')]
             if 'views' in action:
-                action['views'] = form_view + [(state,view) for state,view in action['views'] if view != 'form']
+                action['views'] = form_view + [(state, view) for state, view in action['views'] if view != 'form']
             else:
                 action['views'] = form_view
             action['res_id'] = invoices.id
         else:
             action = {'type': 'ir.actions.act_window_close'}
-
-        context = {
-            'default_move_type': 'out_invoice',
-        }
+        context = {'default_move_type': 'out_invoice'}
         if len(self) == 1:
-            context.update({
-                'default_partner_id': self.partner_id.id,
-                'default_partner_shipping_id': self.partner_shipping_id.id,
-                'default_invoice_payment_term_id': self.payment_term_id.id or self.partner_id.property_payment_term_id.id or self.env['account.move'].default_get(['invoice_payment_term_id']).get('invoice_payment_term_id'),
-                'default_invoice_origin': self.name,
-            })
+            context.update({'default_partner_id': self.partner_id.id, 'default_partner_shipping_id': self.partner_shipping_id.id, 'default_invoice_payment_term_id': self.payment_term_id.id or self.partner_id.property_payment_term_id.id or self.env['account.move'].default_get(['invoice_payment_term_id']).get('invoice_payment_term_id'), 'default_invoice_origin': self.name})
         action['context'] = context
         return action
 
@@ -1454,15 +866,7 @@ class SaleOrder(models.Model):
         return ['company_id', 'partner_id', 'partner_shipping_id', 'currency_id']
 
     def _nothing_to_invoice_error_message(self):
-        return _(
-            "Cannot create an invoice. No items are available to invoice.\n\n"
-            "To resolve this issue, please ensure that:\n"
-            "   \u2022 The products have been delivered before attempting to invoice them.\n"
-            "   \u2022 The invoicing policy of the product is configured correctly.\n\n"
-            "If you want to invoice based on ordered quantities instead:\n"
-            "   \u2022 For consumable or storable products, open the product, go to the 'General Information' tab and change the 'Invoicing Policy' from 'Delivered Quantities' to 'Ordered Quantities'.\n"
-            "   \u2022 For services (and other products), change the 'Invoicing Policy' to 'Prepaid/Fixed Price'.\n"
-        )
+        return _("Cannot create an invoice. No items are available to invoice.\n\nTo resolve this issue, please ensure that:\n   • The products have been delivered before attempting to invoice them.\n   • The invoicing policy of the product is configured correctly.\n\nIf you want to invoice based on ordered quantities instead:\n   • For consumable or storable products, open the product, go to the 'General Information' tab and change the 'Invoicing Policy' from 'Delivered Quantities' to 'Ordered Quantities'.\n   • For services (and other products), change the 'Invoicing Policy' to 'Prepaid/Fixed Price'.\n")
 
     def _get_update_prices_lines(self):
         """ Hook to exclude specific lines which should not be updated based on price list recomputation """
@@ -1475,33 +879,27 @@ class SaleOrder(models.Model):
         section_line_ids = []
         subsection_line_ids = []
         precision = self.env['decimal.precision'].precision_get('Product Unit')
-
         for line in self.order_line:
             if line.display_type == 'line_section':
-                section_line_ids = [line.id]  # Start a new section.
+                section_line_ids = [line.id]
                 subsection_line_ids = []
                 continue
             if line.display_type == 'line_subsection':
-                subsection_line_ids = [line.id]  # Start a new subsection.
+                subsection_line_ids = [line.id]
                 continue
             if line.display_type != 'line_note' and float_is_zero(line.qty_to_invoice, precision_digits=precision):
                 continue
             if line.qty_to_invoice > 0 or (line.qty_to_invoice < 0 and final) or line.display_type == 'line_note':
                 if line.is_downpayment:
-                    # Keep down payment lines separately, to put them together
-                    # at the end of the invoice, in a specific dedicated section.
                     down_payment_line_ids.append(line.id)
                     continue
-                # If the invoicable line is under subsection
                 if subsection_line_ids:
                     if line.display_type:
                         subsection_line_ids.append(line.id)
                         continue
-                    # Extend the subsection lines too if altleast one invoicable line is under subsection
                     invoiceable_line_ids.extend(section_line_ids + subsection_line_ids)
                     subsection_line_ids = []
                     section_line_ids = []
-                # If the invoicable line is under section
                 elif section_line_ids:
                     if line.display_type:
                         section_line_ids.append(line.id)
@@ -1510,13 +908,10 @@ class SaleOrder(models.Model):
                     section_line_ids = []
                     subsection_line_ids = []
                 invoiceable_line_ids.append(line.id)
-
         return self.env['sale.order.line'].browse(invoiceable_line_ids + down_payment_line_ids)
 
     def _create_account_invoices(self, invoice_vals_list, final):
         """Small method to allow overriding the behavior right after an invoice is created."""
-        # Manage the creation of invoices in sudo because a salesperson must be able to generate an invoice from a
-        # sale order without "billing" access rights. However, he should not be able to create an invoice from scratch.
         return self.env['account.move'].sudo().with_context(default_move_type='out_invoice').create(invoice_vals_list)
 
     def _create_invoices(self, grouped=False, final=False, date=None):
@@ -1535,67 +930,38 @@ class SaleOrder(models.Model):
                 self.check_access('write')
             except AccessError:
                 return self.env['account.move']
-
-        # 1) Create invoices.
         invoice_vals_list = []
-        invoice_item_sequence = 0 # Incremental sequencing to keep the lines order on the invoice.
+        invoice_item_sequence = 0
         for order in self:
             if order.partner_invoice_id.lang:
                 order = order.with_context(lang=order.partner_invoice_id.lang)
             order = order.with_company(order.company_id)
-
             invoice_vals = order._prepare_invoice()
             invoiceable_lines = order._get_invoiceable_lines(final)
-
-            if all(line.display_type for line in invoiceable_lines):
+            if all((line.display_type for line in invoiceable_lines)):
                 continue
-
             invoice_line_vals = []
             down_payment_section_added = False
             for line in invoiceable_lines:
                 if not down_payment_section_added and line.is_downpayment:
-                    # Create a dedicated section for the down payments
-                    # (put at the end of the invoiceable_lines)
-                    invoice_line_vals.append(
-                        Command.create(
-                            order._prepare_down_payment_section_line(sequence=invoice_item_sequence)
-                        ),
-                    )
+                    invoice_line_vals.append(Command.create(order._prepare_down_payment_section_line(sequence=invoice_item_sequence)))
                     down_payment_section_added = True
                     invoice_item_sequence += 1
-
                 optional_values = {'sequence': invoice_item_sequence}
-
-                # When creating the final invoice, we want to express the lines representing
-                # the full order but negate the already created down payment lines.
-                # At this point, on the sale order, the down payment lines have a non-empty
-                # 'extra_tax_data' containing a price unit greater than zero and a quantity of 0.0.
                 if line.is_downpayment:
                     optional_values['quantity'] = -1.0
-                    optional_values['extra_tax_data'] = self.env['account.tax']\
-                        ._reverse_quantity_base_line_extra_tax_data(line.extra_tax_data)
-
+                    optional_values['extra_tax_data'] = self.env['account.tax']._reverse_quantity_base_line_extra_tax_data(line.extra_tax_data)
                 for vals in line._prepare_invoice_lines_vals_list(**optional_values):
                     invoice_line_vals.append(Command.create(vals))
-
                 invoice_item_sequence += 1
-
             invoice_vals['invoice_line_ids'] += invoice_line_vals
             invoice_vals_list.append(invoice_vals)
-
         if not invoice_vals_list and self.env.context.get('raise_if_nothing_to_invoice', True):
             raise UserError(self._nothing_to_invoice_error_message())
-
-        # 2) Manage 'grouped' parameter: group by (partner_id, partner_shipping_id, currency_id).
         if not grouped:
             new_invoice_vals_list = []
             invoice_grouping_keys = self._get_invoice_grouping_keys()
-            invoice_vals_list = sorted(
-                invoice_vals_list,
-                key=lambda x: [
-                    x.get(grouping_key) for grouping_key in invoice_grouping_keys
-                ]
-            )
+            invoice_vals_list = sorted(invoice_vals_list, key=lambda x: [x.get(grouping_key) for grouping_key in invoice_grouping_keys])
             for _grouping_keys, invoices in groupby(invoice_vals_list, key=lambda x: [x.get(grouping_key) for grouping_key in invoice_grouping_keys]):
                 origins = set()
                 payment_refs = set()
@@ -1609,34 +975,9 @@ class SaleOrder(models.Model):
                     origins.add(invoice_vals['invoice_origin'])
                     payment_refs.add(invoice_vals['payment_reference'])
                     refs.add(invoice_vals['ref'])
-                ref_invoice_vals.update({
-                    'ref': ', '.join(refs)[:2000],
-                    'invoice_origin': ', '.join(origins),
-                    'payment_reference': len(payment_refs) == 1 and payment_refs.pop() or False,
-                })
+                ref_invoice_vals.update({'ref': ', '.join(refs)[:2000], 'invoice_origin': ', '.join(origins), 'payment_reference': len(payment_refs) == 1 and payment_refs.pop() or False})
                 new_invoice_vals_list.append(ref_invoice_vals)
             invoice_vals_list = new_invoice_vals_list
-
-        # 3) Create invoices.
-
-        # As part of the invoice creation, we make sure the sequence of multiple SO do not interfere
-        # in a single invoice. Example:
-        # SO 1:
-        # - Section A (sequence: 10)
-        # - Product A (sequence: 11)
-        # SO 2:
-        # - Section B (sequence: 10)
-        # - Product B (sequence: 11)
-        #
-        # If SO 1 & 2 are grouped in the same invoice, the result will be:
-        # - Section A (sequence: 10)
-        # - Section B (sequence: 10)
-        # - Product A (sequence: 11)
-        # - Product B (sequence: 11)
-        #
-        # Resequencing should be safe, however we resequence only if there are less invoices than
-        # orders, meaning a grouping might have been done. This could also mean that only a part
-        # of the selected SO are invoiceable, but resequencing in this case shouldn't be an issue.
         if len(invoice_vals_list) < len(self):
             SaleOrderLine = self.env['sale.order.line']
             for invoice in invoice_vals_list:
@@ -1644,40 +985,22 @@ class SaleOrder(models.Model):
                 for line in invoice['invoice_line_ids']:
                     line[2]['sequence'] = SaleOrderLine._get_invoice_line_sequence(new=sequence, old=line[2]['sequence'])
                     sequence += 1
-
         moves = self._create_account_invoices(invoice_vals_list, final)
-
-        # 4) Some moves might actually be refunds: convert them if the total amount is negative
-        # We do this after the moves have been created since we need taxes, etc. to know if the total
-        # is actually negative or not
         if final and (moves_to_switch := moves.sudo().filtered(lambda m: m.amount_total < 0)):
             with self.env.protecting([moves._fields['team_id']], moves_to_switch):
                 moves_to_switch.action_switch_move_type()
                 self.invoice_ids._set_reversed_entry(moves_to_switch)
-
         for move in moves:
-            move.message_post_with_source(
-                'mail.message_origin_link',
-                render_values={'self': move, 'origin': move.line_ids.sale_line_ids.order_id},
-                subtype_xmlid='mail.mt_note',
-            )
+            move.message_post_with_source('mail.message_origin_link', render_values={'self': move, 'origin': move.line_ids.sale_line_ids.order_id}, subtype_xmlid='mail.mt_note')
         return moves
 
-    # MAIL #
-
     def _discard_tracking(self):
         self.ensure_one()
-        return (
-            self.state == 'draft'
-            and request and request.env.context.get('catalog_skip_tracking')
-        )
+        return self.state == 'draft' and request and request.env.context.get('catalog_skip_tracking')
 
     def _track_finalize(self):
         """ Override of `mail` to prevent logging changes when the SO is in a draft state. """
-        if (len(self) == 1
-            # The method _track_finalize is sometimes called too early or too late and it
-            # might cause a desynchronization with the cache, thus this condition is needed.
-            and self.env.cache.contains(self, self._fields['state']) and self._discard_tracking()):
+        if len(self) == 1 and self.env.cache.contains(self, self._fields['state']) and self._discard_tracking():
             self.env.cr.precommit.data.pop(f'mail.tracking.{self._name}', {})
             self.env.flush_all()
             return
@@ -1690,25 +1013,17 @@ class SaleOrder(models.Model):
         return super().message_post(**kwargs)
 
     def _notify_get_recipients_groups(self, message, model_description, msg_vals=False):
-        # Give access button to users and portal customer as portal is integrated
-        # in sale. Customer and portal group have probably no right to see
-        # the document so they don't have the access button.
-        groups = super()._notify_get_recipients_groups(
-            message, model_description, msg_vals=msg_vals
-        )
+        groups = super()._notify_get_recipients_groups(message, model_description, msg_vals=msg_vals)
         if not self:
             return groups
-
         self.ensure_one()
         if self.env.context.get('proforma'):
             for group in [g for g in groups if g[0] in ('portal_customer', 'portal', 'follower', 'customer')]:
                 group[2]['has_button_access'] = False
             return groups
         local_msg_vals = dict(msg_vals or {})
-
-        # portal customers have full access (existence not granted, depending on partner_id)
         try:
-            customer_portal_group = next(group for group in groups if group[0] == 'portal_customer')
+            customer_portal_group = next((group for group in groups if group[0] == 'portal_customer'))
         except StopIteration:
             pass
         else:
@@ -1716,33 +1031,22 @@ class SaleOrder(models.Model):
             is_tx_pending = self.get_portal_last_transaction().state == 'pending'
             if self._has_to_be_signed():
                 if self._has_to_be_paid():
-                    access_opt['title'] = _("View Quotation") if is_tx_pending else _("Sign & Pay Quotation")
+                    access_opt['title'] = _('View Quotation') if is_tx_pending else _('Sign & Pay Quotation')
                 else:
-                    access_opt['title'] = _("Accept & Sign Quotation")
-            elif self._has_to_be_paid() and not is_tx_pending:
-                access_opt['title'] = _("Accept & Pay Quotation")
+                    access_opt['title'] = _('Accept & Sign Quotation')
+            elif self._has_to_be_paid() and (not is_tx_pending):
+                access_opt['title'] = _('Accept & Pay Quotation')
             elif self.state in ('draft', 'sent'):
-                access_opt['title'] = _("View Quotation")
-
+                access_opt['title'] = _('View Quotation')
         return groups
 
-    def _notify_by_email_prepare_rendering_context(self, message, msg_vals=False, model_description=False,
-                                                   force_email_company=False, force_email_lang=False,
-                                                   force_record_name=False):
-        render_context = super()._notify_by_email_prepare_rendering_context(
-            message, msg_vals=msg_vals, model_description=model_description,
-            force_email_company=force_email_company, force_email_lang=force_email_lang,
-            force_record_name=force_record_name,
-        )
+    def _notify_by_email_prepare_rendering_context(self, message, msg_vals=False, model_description=False, force_email_company=False, force_email_lang=False, force_record_name=False):
+        render_context = super()._notify_by_email_prepare_rendering_context(message, msg_vals=msg_vals, model_description=model_description, force_email_company=force_email_company, force_email_lang=force_email_lang, force_record_name=force_record_name)
         lang_code = render_context.get('lang')
         record = render_context['record']
-        subtitles = [f"{record.name} - {record.partner_id.name}" if record.partner_id.name else record.name]
+        subtitles = [f'{record.name} - {record.partner_id.name}' if record.partner_id.name else record.name]
         if self.amount_total:
-            # Do not show the price in subtitles if zero (e.g. e-commerce orders are created empty)
-            subtitles.append(
-                format_amount(self.env, self.amount_total, self.currency_id, lang_code=lang_code),
-            )
-
+            subtitles.append(format_amount(self.env, self.amount_total, self.currency_id, lang_code=lang_code))
         render_context['subtitles'] = subtitles
         return render_context
 
@@ -1759,8 +1063,6 @@ class SaleOrder(models.Model):
             return self.env.ref('sale.mt_order_sent')
         return super()._track_subtype(init_values)
 
-    # PAYMENT #
-
     def _force_lines_to_invoice_policy_order(self):
         """Force the qty_to_invoice to be computed as if the invoice_policy
         was set to "Ordered quantities", independently of the product configuration.
@@ -1770,22 +1072,17 @@ class SaleOrder(models.Model):
         """
         for line in self.order_line:
             if line.state == 'sale':
-                # No need to set 0 as it is already the standard logic in the compute method.
                 line.qty_to_invoice = line.product_uom_qty - line.qty_invoiced
 
     def payment_action_capture(self):
         """ Capture all transactions linked to this sale order. """
         self.ensure_one()
         payment_utils.check_rights_on_recordset(self)
-
-        # In sudo mode to bypass the checks on the rights on the transactions.
         return self.sudo().transaction_ids.action_capture()
 
     def payment_action_void(self):
         """ Void all transactions linked to this sale order. """
         payment_utils.check_rights_on_recordset(self)
-
-        # In sudo mode to bypass the checks on the rights on the transactions.
         self.sudo().authorized_transaction_ids.action_void()
 
     def get_portal_last_transaction(self):
@@ -1793,50 +1090,24 @@ class SaleOrder(models.Model):
         return self.sudo().transaction_ids._get_last()
 
     def _get_order_lines_to_report(self):
-        down_payment_lines = self.order_line.filtered(lambda line:
-            line.is_downpayment
-            and not line.display_type
-            and not line._get_downpayment_state()
-        )
+        down_payment_lines = self.order_line.filtered(lambda line: line.is_downpayment and (not line.display_type) and (not line._get_downpayment_state()))
 
         def show_line(line):
             if line.is_downpayment:
-                return (
-                    # Only show the down payment section if down payments were posted
-                    (line.display_type and down_payment_lines)
-                    # Only show posted down payments
-                    or line in down_payment_lines
-                )
-            return (
-                line.display_type == 'line_section'
-                or not (
-                    line.parent_id.collapse_composition
-                    or line.parent_id.parent_id.collapse_composition
-                )
-            )
-
+                return line.display_type and down_payment_lines or line in down_payment_lines
+            return line.display_type == 'line_section' or not (line.parent_id.collapse_composition or line.parent_id.parent_id.collapse_composition)
         return self.order_line.filtered(show_line)
 
     def _get_default_payment_link_values(self):
         """ Override of `payment` to compute the default values of the payment link wizard. """
         self.ensure_one()
-
         prepayment_amount = self._get_prepayment_required_amount()
         remaining_balance = self.amount_total - self.amount_paid
         if self.state in ('draft', 'sent') and self.require_payment:
-            suggested_amount = prepayment_amount  # Suggest the amount needed to confirm the quote.
-        else:  # The order is confirmed or doesn't require payment.
+            suggested_amount = prepayment_amount
+        else:
             suggested_amount = remaining_balance
-        return {
-            'currency_id': self.currency_id.id,
-            'partner_id': self.partner_invoice_id.id,
-            'amount': suggested_amount,
-            'amount_max': remaining_balance,
-            'amount_paid': self.amount_paid,
-            'prepayment_amount': prepayment_amount,
-        }
-
-    # EDI #
+        return {'currency_id': self.currency_id.id, 'partner_id': self.partner_invoice_id.id, 'amount': suggested_amount, 'amount_max': remaining_balance, 'amount_paid': self.amount_paid, 'prepayment_amount': prepayment_amount}
 
     def _get_edi_builders(self):
         return []
@@ -1850,13 +1121,9 @@ class SaleOrder(models.Model):
         """
         attachments = self.env['ir.attachment'].browse(attachment_ids)
         if not attachments:
-            raise UserError(_("No attachment was provided"))
-
+            raise UserError(_('No attachment was provided'))
         orders = self.with_context(default_partner_id=self.env.user.partner_id.id)._create_records_from_attachments(attachments)
-
-        return orders._get_records_action(name=_("Generated Orders"))
-
-    # PORTAL #
+        return orders._get_records_action(name=_('Generated Orders'))
 
     def _has_to_be_signed(self):
         """A sale order has to be signed when:
@@ -1871,12 +1138,7 @@ class SaleOrder(models.Model):
         :rtype: bool
         """
         self.ensure_one()
-        return (
-            self.state in ['draft', 'sent']
-            and not self.is_expired
-            and self.require_signature
-            and not self.signature
-        )
+        return self.state in ['draft', 'sent'] and (not self.is_expired) and self.require_signature and (not self.signature)
 
     def _has_to_be_paid(self):
         """A sale order has to be paid when:
@@ -1893,13 +1155,7 @@ class SaleOrder(models.Model):
         :rtype: bool
         """
         self.ensure_one()
-        return (
-            self.state in ['draft', 'sent']
-            and not self.is_expired
-            and self.require_payment
-            and self.amount_total > 0
-            and not self._is_confirmation_amount_reached()
-        )
+        return self.state in ['draft', 'sent'] and (not self.is_expired) and self.require_payment and (self.amount_total > 0) and (not self._is_confirmation_amount_reached())
 
     def _get_portal_return_action(self):
         """ Return the action used to display orders when returning from customer portal. """
@@ -1919,42 +1175,27 @@ class SaleOrder(models.Model):
         self.ensure_one()
         return f'{self.type_name} {self.name}'
 
-    #=== CORE METHODS OVERRIDES ===#
-
     @api.model
     def get_empty_list_help(self, help_message):
-        self = self.with_context(
-            empty_list_help_document_name=_("sale order"),
-        )
+        self = self.with_context(empty_list_help_document_name=_('sale order'))
         return super().get_empty_list_help(help_message)
 
     def _compute_field_value(self, field):
         if field.name != 'invoice_status' or self.env.context.get('mail_activity_automation_skip'):
             return super()._compute_field_value(field)
-
-        filtered_self = self.filtered(
-            lambda so: so.ids
-                and (so.user_id or so.partner_id.user_id)
-                and so._origin.invoice_status != 'upselling')
+        filtered_self = self.filtered(lambda so: so.ids and (so.user_id or so.partner_id.user_id) and (so._origin.invoice_status != 'upselling'))
         super()._compute_field_value(field)
-
         upselling_orders = filtered_self.filtered(lambda so: so.invoice_status == 'upselling')
         upselling_orders._create_upsell_activity()
 
-    #=== BUSINESS METHODS ===#
-
     def _create_upsell_activity(self):
         if not self:
             return
-
         self.activity_unlink(['mail.mail_activity_data_todo'])
         for order in self:
             order_ref = order._get_html_link()
             customer_ref = order.partner_id._get_html_link()
-            order.activity_schedule(
-                'mail.mail_activity_data_todo',
-                user_id=order.user_id.id or order.partner_id.user_id.id,
-                note=_("Upsell %(order)s for customer %(customer)s", order=order_ref, customer=customer_ref))
+            order.activity_schedule('mail.mail_activity_data_todo', user_id=order.user_id.id or order.partner_id.user_id.id, note=_('Upsell %(order)s for customer %(customer)s', order=order_ref, customer=customer_ref))
 
     def _prepare_analytic_account_data(self, prefix=None):
         """ Prepare SO analytic account creation values.
@@ -1965,15 +1206,9 @@ class SaleOrder(models.Model):
         self.ensure_one()
         name = self.name
         if prefix:
-            name = prefix + ": " + self.name
+            name = prefix + ': ' + self.name
         project_plan, _other_plans = self.env['account.analytic.plan']._get_all_plans()
-        return {
-            'name': name,
-            'code': self.client_order_ref,
-            'company_id': self.company_id.id,
-            'plan_id': project_plan.id,
-            'partner_id': self.partner_id.id,
-        }
+        return {'name': name, 'code': self.client_order_ref, 'company_id': self.company_id.id, 'plan_id': project_plan.id, 'partner_id': self.partner_id.id}
 
     def _prepare_down_payment_section_line(self, **optional_values):
         """ Prepare the values to create a new down payment section.
@@ -1984,17 +1219,7 @@ class SaleOrder(models.Model):
         """
         self.ensure_one()
         context = {'lang': self.partner_id.lang}
-        down_payments_section_line = {
-            'display_type': 'line_section',
-            'name': _("Down Payments"),
-            'product_id': False,
-            'product_uom_id': False,
-            'quantity': 0,
-            'discount': 0,
-            'price_unit': 0,
-            'account_id': False,
-            **optional_values
-        }
+        down_payments_section_line = {'display_type': 'line_section', 'name': _('Down Payments'), 'product_id': False, 'product_uom_id': False, 'quantity': 0, 'discount': 0, 'price_unit': 0, 'account_id': False, **optional_values}
         del context
         return down_payments_section_line
 
@@ -2007,15 +1232,7 @@ class SaleOrder(models.Model):
         """
         self.ensure_one()
         sequence = max(self.order_line.mapped('sequence') or [10]) + 1
-        return self.env['sale.order.line'] \
-            .with_context(sale_no_log_for_new_lines=True) \
-            .create([
-                {
-                    **self._prepare_down_payment_line_values_from_base_line(base_line),
-                    'sequence': sequence + index,
-                }
-                for index, base_line in enumerate(down_payment_base_lines)
-            ])
+        return self.env['sale.order.line'].with_context(sale_no_log_for_new_lines=True).create([{**self._prepare_down_payment_line_values_from_base_line(base_line), 'sequence': sequence + index} for index, base_line in enumerate(down_payment_base_lines)])
 
     def _create_down_payment_section_line_if_needed(self):
         """ Add the down section line if not already there on the current SO.
@@ -2023,18 +1240,10 @@ class SaleOrder(models.Model):
         :return The newly created SO line or None if the section was already there.
         """
         self.ensure_one()
-        # If a down payment is already there, then the section is not needed and
-        # has already been created.
-        if any(line.display_type and line.is_downpayment for line in self.order_line):
+        if any((line.display_type and line.is_downpayment for line in self.order_line)):
             return
-
         sequence = max(self.order_line.mapped('sequence') or [10]) + 1
-        return self.env['sale.order.line'] \
-            .with_context(sale_no_log_for_new_lines=True) \
-            .create({
-                **self._prepare_down_payment_line_section_values(),
-                'sequence': sequence,
-            })
+        return self.env['sale.order.line'].with_context(sale_no_log_for_new_lines=True).create({**self._prepare_down_payment_line_section_values(), 'sequence': sequence})
 
     def _prepare_down_payment_line_section_values(self):
         """ Prepare the values to create a section line for the down payment on the current SO.
@@ -2042,11 +1251,7 @@ class SaleOrder(models.Model):
         :return: A dictionary to create a new SO section line.
         """
         self.ensure_one()
-        return {
-            'order_id': self.id,
-            'display_type': 'line_section',
-            'is_downpayment': True,
-        }
+        return {'order_id': self.id, 'display_type': 'line_section', 'is_downpayment': True}
 
     def _prepare_down_payment_line_values_from_base_line(self, base_line):
         """ Convert the base line passed as parameter representing a down payment into a
@@ -2057,15 +1262,7 @@ class SaleOrder(models.Model):
         """
         self.ensure_one()
         extra_tax_data = self.env['account.tax']._export_base_line_extra_tax_data(base_line)
-        return {
-            'order_id': self.id,
-            'is_downpayment': True,
-            'product_uom_qty': 0.0,
-            'price_unit': base_line['price_unit'],
-            'tax_ids': [Command.set(base_line['tax_ids'].ids)],
-            'analytic_distribution': base_line['analytic_distribution'],
-            'extra_tax_data': extra_tax_data,
-        }
+        return {'order_id': self.id, 'is_downpayment': True, 'product_uom_qty': 0.0, 'price_unit': base_line['price_unit'], 'tax_ids': [Command.set(base_line['tax_ids'].ids)], 'analytic_distribution': base_line['analytic_distribution'], 'extra_tax_data': extra_tax_data}
 
     def _get_prepayment_required_amount(self):
         """ Return the minimum amount needed to automatically confirm the quotation.
@@ -2076,7 +1273,6 @@ class SaleOrder(models.Model):
         :rtype: float
         """
         self.ensure_one()
-
         if not self.require_payment:
             return 0
         else:
@@ -2091,9 +1287,7 @@ class SaleOrder(models.Model):
         :rtype: bool
         """
         self.ensure_one()
-        amount_comparison = self.currency_id.compare_amounts(
-            self._get_prepayment_required_amount(), self.amount_paid,
-        )
+        amount_comparison = self.currency_id.compare_amounts(self._get_prepayment_required_amount(), self.amount_paid)
         return amount_comparison <= 0
 
     def _generate_downpayment_invoices(self):
@@ -2103,27 +1297,13 @@ class SaleOrder(models.Model):
         :rtype: recordset of `account.move`
         """
         generated_invoices = self.env['account.move']
-
         for order in self:
-            downpayment_wizard = order.env['sale.advance.payment.inv'].create({
-                'sale_order_ids': order,
-                'advance_payment_method': 'fixed',
-                'fixed_amount': order.amount_paid,
-            })
+            downpayment_wizard = order.env['sale.advance.payment.inv'].create({'sale_order_ids': order, 'advance_payment_method': 'fixed', 'fixed_amount': order.amount_paid})
             generated_invoices |= downpayment_wizard._create_invoices(order)
-
         return generated_invoices
 
-    # === CATALOG === #
-
     def _get_product_catalog_order_data(self, products, **kwargs):
-        pricelist = self.pricelist_id._get_products_price(
-            quantity=1.0,
-            products=products,
-            currency=self.currency_id,
-            date=self.date_order,
-            **kwargs,
-        )
+        pricelist = self.pricelist_id._get_products_price(quantity=1.0, products=products, currency=self.currency_id, date=self.date_order, **kwargs)
         res = super()._get_product_catalog_order_data(products, **kwargs)
         for product in products:
             res[product.id]['price'] = pricelist.get(product.id)
@@ -2134,17 +1314,9 @@ class SaleOrder(models.Model):
     def _get_product_catalog_record_lines(self, product_ids, *, section_id=None, **kwargs):
         grouped_lines = defaultdict(lambda: self.env['sale.order.line'])
         if section_id is None:
-            section_id = (
-                self.order_line[:1].id
-                if self.order_line[:1].display_type == 'line_section'
-                else False
-            )
+            section_id = self.order_line[:1].id if self.order_line[:1].display_type == 'line_section' else False
         for line in self.order_line:
-            if (
-                line.display_type
-                or line.product_id.id not in product_ids
-                or line.get_parent_section_line().id != section_id
-            ):
+            if line.display_type or line.product_id.id not in product_ids or line.get_parent_section_line().id != section_id:
                 continue
             grouped_lines[line.product_id] |= line
         return grouped_lines
@@ -2152,9 +1324,7 @@ class SaleOrder(models.Model):
     def _get_parent_field_on_child_model(self):
         return 'order_id'
 
-    def _update_order_line_info(
-        self, product_id, quantity, *, section_id=False, child_field='order_line', **kwargs
-    ):
+    def _update_order_line_info(self, product_id, quantity, *, section_id=False, child_field='order_line', **kwargs):
         """ Update sale order line information for a given product or create a
         new one if none exists yet.
         :param int product_id: The product, as a `product.product` id.
@@ -2165,53 +1335,27 @@ class SaleOrder(models.Model):
         :rtype: float
         """
         request.update_context(catalog_skip_tracking=True)
-        sol = self.order_line.filtered(
-            lambda l: l.product_id.id == product_id
-            and l.get_parent_section_line().id == section_id,
-        )
+        sol = self.order_line.filtered(lambda l: l.product_id.id == product_id and l.get_parent_section_line().id == section_id)
         if sol:
             if quantity != 0:
                 sol.product_uom_qty = quantity
             elif self.state in ['draft', 'sent']:
-                price_unit = self.pricelist_id._get_product_price(
-                    product=sol.product_id,
-                    quantity=1.0,
-                    currency=self.currency_id,
-                    date=self.date_order,
-                    **kwargs,
-                )
+                price_unit = self.pricelist_id._get_product_price(product=sol.product_id, quantity=1.0, currency=self.currency_id, date=self.date_order, **kwargs)
                 sol.unlink()
                 return price_unit
             else:
                 sol.product_uom_qty = 0
         elif quantity > 0:
-            sol = self.env['sale.order.line'].create({
-                'order_id': self.id,
-                'product_id': product_id,
-                'product_uom_qty': quantity,
-                'sequence': self._get_new_line_sequence(child_field, section_id),
-            })
-        return sol.price_unit * (1-(sol.discount or 0.0)/100.0)
-
-    # === Product Documents === #
+            sol = self.env['sale.order.line'].create({'order_id': self.id, 'product_id': product_id, 'product_uom_qty': quantity, 'sequence': self._get_new_line_sequence(child_field, section_id)})
+        return sol.price_unit * (1 - (sol.discount or 0.0) / 100.0)
 
     def _get_product_documents(self):
         self.ensure_one()
-
-        documents = (
-            self.order_line.product_id.product_document_ids
-            | self.order_line.product_template_id.product_document_ids
-        )
+        documents = self.order_line.product_id.product_document_ids | self.order_line.product_template_id.product_document_ids
         return self._filter_product_documents(documents).sorted()
 
     def _filter_product_documents(self, documents):
-        return documents.filtered(
-            lambda document:
-                document.attached_on_sale == 'quotation'
-                or (self.state == 'sale' and document.attached_on_sale == 'sale_order')
-        )
-
-    #=== TOOLING ===#
+        return documents.filtered(lambda document: document.attached_on_sale == 'quotation' or (self.state == 'sale' and document.attached_on_sale == 'sale_order'))
 
     def _is_readonly(self):
         """ Return Whether the sale order is read-only or not based on the state or the lock status.
@@ -2239,20 +1383,14 @@ class SaleOrder(models.Model):
 
     def _get_lang(self):
         self.ensure_one()
-
-        if self.partner_id.lang and not self.partner_id.is_public:
+        if self.partner_id.lang and (not self.partner_id.is_public):
             return self.partner_id.lang
-
         return self.env.lang
 
     @api.model
     def get_import_templates(self):
-        return [{
-            'label': _('Import Template for Quotations'),
-            'template': '/sale/static/xls/quotations_import_template.xlsx',
-        }]
+        return [{'label': _('Import Template for Quotations'), 'template': '/sale/static/xls/quotations_import_template.xlsx'}]
 
-    # For `sale_management`, to control optional products on portal
     def _can_be_edited_on_portal(self):
         self.ensure_one()
-        return self.state in ('draft', 'sent')
+        return self.state in ('draft', 'sent')
\ No newline at end of file
